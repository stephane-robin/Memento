<!DOCTYPE HTML>
<html>
<head>
  <title> Memento </title>
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="prism.css">
  <meta charset="utf-8">
</head>

<!-- script de gestion des couleurs de code -->
<script defer src="prism.js"></script>

<!-- script de gestion de l'apparition du contenu d'une section -->
<script type="text/javascript">
function affichageConditionnel(bouton, id) {
    var div = document.getElementById(id);
    if(div.style.display=="none") { // si le div est masqué, on l'affiche et on change le contenu du bouton
        div.style.display = "block";
        bouton.innerHTML = "-";
    } else { // s'il est visible, on le masque et on change le contenu du bouton
        div.style.display = "none";
        bouton.innerHTML = "+";
    }
}</script>

<body>

<!-- Image de présentation-->
<header>
  <div class="heroImage">
    <div class="heroTexte">
      <h2> Python </h2>
    </div>
  </div>
</header>

<!-- Bandeau et menu -->
<div id="bandeau">
  <div id="titre"> <h1> Memento </h1> </div>
  <nav>
    <div class="element"> <a href="html.html">HTML</a> </div>
    <div class="element"> <a href="css.html">CSS</a> </div>
    <div class="element"> <a href="javascript.html">JAVASCRIPT</a> </div>
    <div class="element"> <a href="python.html">PYTHON</a> </div>
    <div class="element"> <a href="java.html">JAVA</a> </div>
    <div class="element"> <a href="c.html">C</a> </div>
    <div class="element"> <a href="git.html">GIT</a> </div>
  </nav>
</div>

<section id="principal">

<p style="font-weight:bold"> Table des matières :</p>
  <ul>
    <li> <a href="#py_generalites">Généralités</a> </li>
    <li> <a href="#py_hello">Hello world</a> </li>
    <li> <a href="#py_saisie">Saisie d'une valeur par l'utilisateur</a> </li>
    <li> <a href="#py_import_package">Importer un package</a> </li>
    <li> <a href="#py_variable">Les variables</a> </li>
    <li> <a href="#py_chaine">Manipuler des chaînes de caractères</a> </li>
    <li> <a href="#py_condition">Branchement conditionnel</a> </li>
    <li> <a href="#py_boucle">Les boucles</a> </li>
    <li> <a href="#py_tableau">Les tableaux</a> </li>
    <li> <a href="#py_liste">Les listes</a> </li>
    <li> <a href="#py_liste_avance">Utilisation avancée des listes</a> </li>
    <li> <a href="#py_dictionnaire">Les dictionnaires</a> </li>
    <li> <a href="#py_fonction">Les fonctions</a> </li>
    <li> <a href="#py_exception">Les exceptions</a> </li>
    <li> <a href="#py_objet">La programmation objet</a> </li>
    <li> <a href="#py_random">Le package random</a> </li>
    <li> <a href="#py_math">Le package math</a> </li>
    <li> <a href="#py_fraction">Le package fractions</a> </li>
    <li> <a href="#py_numpy">Le package Numpy</a> </li>
    <li> <a href="#py_json">Le package JSON</a> </li>
    <li> <a href="#py_creer_package">Créer un package</a> </li>
    <li> <a href="#py_pep">Respect du PEP8</a> </li>
  </ul>



  <!-- ===== GENERALITES ===== -->

  <h3 id="py_generalites"> Généralités </h3>

  <p>Les fichiers Python ont pour extension <em>.py</em></p>

  <p>Les commentaires sont indiqués à l'aide de <strong>#</strong> pour une seule ligne ou <strong>"""   """</strong> pour plusieurs lignes.</p>

  <p>En Python, les blocs ne sont pas encadrés par des <strong>{}</strong> comme dans la plupart des langages, ce sont les indentations qui indiquent à l'interpréteur le début et la fin d'un bloc. En conséquence, il est important de respecter toujours la même procédure d'indentation. On utilisera 4 espaces plutôt qu'une tabulation pour exprimer une indentation, ceci afin d'assurer une bonne portabilité du code.</p>

  <p>En Python, les mots clés à ne pas utiliser comme nom de variable ou de fonction sont les suivants:<br>
    <strong>and, or, del, from, none, as, global, nonlocal, try, assert, else, if, elif, not, while, for, except, import, with, class, true, false, in, pass, yield, continue, break, finally, is, raise, def, lambda, return</strong>.</p>

  <h4>Particularité d'une exécution de code au Terminal sous Linux et Mac</h4>

  <p>Pour connaître la version de Python utilisée : </p>
  <pre><code>python --version</code></pre>

  <p>Pour connaître le chemin vers le dossier Python :</p>
  <pre><code>which python</code></pre>

  <p>Il est souvent nécessaire de placer en début de code le chemin absolu de l'interpréteur (ici 3.7 représente la version de Python), et de préciser l'encodage UTF-8 :</p>
  <pre><code class="language-python">#!/usr/bin/python3.7
# -*-coding:Utf-8 -*</code></pre>

  <h4>Particularité du système Windows</h4>

  <p>Il est nécessaire de mettre en pause le programme en fin d'exécution afin de pouvoir lire le résultat. Préciser l'encodage peut s'avérer nécessaire sous Windows.</p>
  <pre><code class="language-python"># -*-coding:Latin-1 -*
import os
# le programme se trouve ici
os.system("pause")</code></pre>



  <!-- ===== HELLO WORLD ===== -->

<h3 id="py_hello">Hello world</h3>

<p>Commençons par le traditionnel "Hello world". Contrairement à beaucoup de langages, Python n'utilise pas de <strong>;</strong> à la fin de chaque instruction. Il le remplace par un retour à la ligne. Notons que les accolades symbolisant un bloc sont remplacées par une indentation.</p>
  <pre><code class="language-javascript">print("Hello World");</code></pre>

<p>A noter que <em>print</em> entraîne systématiquement un retour à la ligne, contrairement à certains autres langages où il faut rajouter ln
pour aller à la ligne. Pour éviter un retour à la ligne, on utilise l'instruction print("hello", end = "")</p>



  <!-- ===== SAISIE D'UNE VALEUR PAR L'UTILISATEUR ===== -->

  <h3 id="py_saisie">Saisie d'une valeur par l'utilisateur</h3>

  <pre><code class="language-python">nom = input("Quel est votre nom ?");
print("Bonjour ",nom);</code></pre>

  <p></p>

  <fieldset><legend>ATTENTION </legend>
    <p>La valeur saisie est systématiquement de type <em>String</em>. Il convient donc de la transformer en nombre le cas échéant.</p>
  </fieldset>

  <pre><code class="language-python">age = int(input("Quel est votre âge ?"))
print("Dans deux ans vous aurez ", age+2)</code></pre>



<!-- ===== IMPORTER UN PACKAGE ===== -->

<h3 id="py_import_package">Importer un package</h3>

  <pre><code class="language-python">import nomPackage as np</code></pre>

<p>Chaque fonction du package sera ensuite appelée avec le préfixe <em>np</em>.</p>
  <pre><code class="language-python">np.maFonction(5)</code></pre>

<p>On peut également importer un package sans le renommer à l'aide d'un préfixe, lorsqu'il n'y a aucun risque de confusion entre les fonctions.</p>
  <pre><code class="language-python">import nomPackage</code></pre>

<p>Dans ce cas, il faudra appeler chaque fonction en utilisant <em>nomPackage</em> comme préfixe.</p>
  <pre><code class="language-python">nomPackage.maFonction(5)</code></pre>

<p>Pour le package math, on préfère utiliser l'instruction suivante pour éviter d'ajouter un préfixe à chaque calcul :</p>
  <pre><code class="language-python">from math import *</code></pre>

  <h4>Particularité Python pour l'importation d'un package</h4>

  <p>Pour éviter qu'une méthode main() ne se lance à l'importation, on peut utiliser une condition qui lance la méthode uniquement si elle est appelée :</p>

  <pre><code class="language-python">if __name__ == "__main__":
  main()</code></pre>

  <p>Parmi les packages importants, on trouve Matplotlib utilisé pour les graphiques, Numpy utilisé pour manipuler des séries de nombres, Pandas utilisé pour utiliser des données sous une forme de tableur.</p>



<!-- ===== LES VARIABLES ===== -->

<h3 id="py_variable">Les variables</h3>

  <h4> Types </h4>

  <p>Python est un langage à typage dynamique, i.e. qu'il identifie lui-même les types de variables et autorise les changements de type. La déclaration des variables n'est donc pas nécessaire. L'instruction <strong>int(chaine)</strong> permet de transformer un <em>String</em> en nombre <em>si cela est possible</em> alors que l'instruction <strong>str(nombre)</strong> permet de transformer un nombre en <em>String</em>.</p>
  <p>Par ailleurs, Python est un langage fortement typé, i.e. qu'il ne convertit pas automatiquement les types de variables, mais requiert une instruction spécifique. Ainsi, la concaténation d'un <em>String</em> avec un entier lève une exception et ne transforme pas l'entier en <em>String</em>.</p>
  <p>Pour tester le type d'une variable, on utilise l'instruction <strong>type(maVariable)</strong>. Cette instruction lève une exception si maVariable n'existe pas. En revanche, elle renvoie le type si maVariable a été déclarée mais reste vide.</p>

  <table>
    <tr><th>Types</th><th>Mots-clés</th></tr>
    <tr><td>entier</td><td>int</td></tr>
    <tr><td>nombre décimal</td><td>float</td></tr>
    <tr><td>nombre complexe</td><td>complex</td></tr>
    <tr><td>chaîne de caractères</td><td>str</td></tr>
    <tr><td>booléen</td><td>bool</td></tr>
  </table>

  <p>Les booléens prennent les valeurs <strong>True</strong> et <strong>False</strong>.</p>
  <p>Il n'existe pas de type StringBuffer comme en Java pour représenter les chaînes de caractères modifiables.</p>

  <h4>Particularité de Python</h4>

  <p>Python permet de permuter simplement les valeurs de deux variables sans passer par une troisième.</p>
  <pre><code class="language-python">a = 2
b = 5
a, b = b, a</code></pre>

  <h4> Les principales opérations </h4>

  <table>
    <tr><th>Opérations</th><th>Symboles</th></tr>
    <tr><td>addition</td><td>+</td></tr>
    <tr><td>soustraction</td><td>-</td></tr>
    <tr><td>multiplication</td><td>*</td></tr>
    <tr><td>division</td><td>/</td></tr>
    <tr><td>modulo</td><td>%</td></tr>
    <tr><td>partie entière d'une division</td><td>//</td></tr>
    <tr><td>concaténation</td><td>+</td></tr>
    <tr><td>affectation</td><td>=</td></tr>
    <tr><td>égalité</td><td>==</td></tr>
    <tr><td>incrémentation</td><td>++</td></tr>
    <tr><td>décrémentation</td><td>--</td></tr>
    <tr><td>ET logique</td><td>and</td></tr>
    <tr><td>OU logique</td><td>or</td></tr>
    <tr><td>NON logique</td><td>! ou  not</td></tr>
  </table>

  <h4>Les opérateurs de comparaison</h4>

  <table>
    <tr><th>Signification</th><th>Opérateurs</th></tr>
    <tr><td>égalité</td><td>==</td></tr>
    <tr><td>égalité (valeur et type)</td><td>===</td></tr>
    <tr><td>différent</td><td>!=</td></tr>
    <tr><td>inférieur</td><td><</td></tr>
    <tr><td>inférieur ou égal</td><td><=</td></tr>
    <tr><td>supérieur</td><td>></td></tr>
    <tr><td>supérieur ou égal</td><td>>=</td></tr>
  </table>

  <h4>Les constantes</h4>

  <p>Les constantes n'existent pas en Python. On utilise généralement des variables globales qu'on ne modifie pas.</p>



<!-- ===== MANIPULER DES CHAINES DE CARACTERES ===== -->

<h3 id="py_chaine">Manipuler des chaînes de caractères</h3>

  <p>L'indice du 1er caractère d'une chaîne est 0. Pour échapper une apostrophe ou un guillemet, on utilise le signe <strong>\</strong>.<p>

  <table>
    <tr><th>Propriétés</th><th>Codes</th></tr>
    <tr><td>taille</td><td><pre>len(chaine)</pre></td></tr>
    <tr><td>élément d'indice i</td><td><pre>chaine[i]</pre></td></tr>
    <tr><td>dernier élément</td><td><pre>chaine[-1]</pre></td></tr>
    <tr><td>convertir en minuscules</td><td><pre>chaine.lower()</pre></td></tr>
    <tr><td>convertir en majuscules</td><td><pre>chaine.upper()</pre></td></tr>
    <tr><td>mettre en majuscule le 1er caractère d'une chaîne</td><td><pre>chaine.capitalize()</pre></td></tr>
    <tr><td>nombre de "d" dans la chaîne</td><td><pre>chaine.count("d")</pre></td></tr>
    <tr><td>remplacement de "d" par "a"</td><td><pre>chaine.replace("d", "a")</pre></td></tr>
    <tr><td>enlever les espaces au début et à la fin d'une chaine</td><td><pre>chaine.strip()</pre></td></tr>
    <tr><td>extrait une sous-chaîne, comprenant la lettre d'indice 3 jusqu'à la lettre d'indice 5 incluse</td><td><pre>chaine[3:6]</pre></td></tr>
    <tr><td>extrait une sous-chaîne, comprenant la lettre d'indice 3 jusqu'à la lettre d'indice 5 incluse</td><td><pre>chaine[3:6]</pre></td></tr>
    <tr><td>comparaison</td><td>===</td></tr>
    <tr><td>concaténation</td><td>+</td></tr>
    <tr><td>retour à la ligne</td><td>\n</td></tr>
    <tr><td>tabulation</td><td>\t</td></tr>
    <tr><td>transformer une chaîne en liste élément par élément</td><td><pre>liste = chaine.split()</pre></td></tr>
    <tr><td>transformer une chaîne avec le séparateur - en liste</td><td><pre>liste = chaine.split("-");</pre></td></tr>
    <tr><td>transformer une liste en chaîne contenant le séparateur - </td><td><pre>chaine = "-".join(maListe)</pre></td></tr>
    <tr><td>recherche de "non" dans une chaine. Renvoie -1  si le caractère recherché ne se trouve pas dans la chaîne</td><td><pre>chaine.indexOf("non")</pre></td></tr>
    <tr><td>retour à la ligne</td><td>\n</td></tr>
    <tr><td>test si le contenu de la chaîne est numérique. Renvoie un booléen</td><td><pre>chaine.isnumeric()</pre></td></tr>
  </table>

  <p>L'utilisation d'un indice qui n'existe pas dans la chaîne lève une exception de type <em>IndexError</em>.</p>
  <p>Il n'est pas possible de modifier un caractère d'une chaîne de la façon suivante <em>chaine[4] = "Antoine"</em>. Il s'agit en fait d'une protection des chaînes qui pourront être modifiées par instruction explicite du développeur.</p>

  <h4>Parcourir une chaîne de caractères élément par élément</h4>

  <pre><code class="language-python">for(let i=0; i&ltchaine.length; i++){
  chaine[i];
}</code></pre>

  <h4>Template literal</h4>

  <p>Python permet d'inclure des expressions dans une chaîne de caractères appelées <em>template literal</em>. Pour cela, il faut définir les emplacement avec <strong>{}</strong> et utiliser la méthode <strong>format()</strong>.</p>
  <pre><code class="language-python">{} est le fils de {}.format("Antoine", "Albert")</code></pre>

  <h4>Caster une chaîne de caractères</h4>

  <p>Il est possible de caster une chaîne de caractères lorsque ceux-ci s'apparentent à des nombres. Pour cela, on utilise
  les méthodes int() et float(). Cela s'avère utile lorsqu'on demande à un utilisateur de saisir un nombre. Ce dernier est
  nativement enregistré au format d'une chaîne de caractères qu'il faut caster pour pouvoir appliquer des opérations numériques.</p>

  <pre><code class="language-python">chaine = "12"
nombre = int(chaine)</code></pre>



  <!-- ===== BRANCHEMENT CONDITIONNEL ===== -->

  <h3 id="py_condition">Branchement conditionnel</h3>

    <h4>La condition if</h4>

    <pre><code class="language-python">if condition :
  instructions
else :
instructions</code></pre>

    <h4>Particularités de Python</h4>

    <p>L'instruction <strong>elif</strong> est la contraction de l'instruction <strong>else if</strong>.</p>

    <pre><code class="language-python">if condition :
  instructions
elif condition :
  instructions
else :
  instructions</code></pre>
    
    <p>L'instruction <strong>switch</strong> n'existe pas de façon native en Python.</p>



  <!-- ===== LES BOUCLES ===== -->

  <h3 id="py_boucle"> Les boucles </h3>

  <h4>La boucle for</h4>

  <p>Pour une répétition allant de 0 à 4 :</p>
    <pre><code class="language-python">for i in range(0, 5):
  instructions</code></pre>

  <p>Pour parcourir tous les éléments d'une liste ou d'un tableau:</p>
  <pre><code class="language-python">for elmt in liste:
  print(elt) # ou une quelconque instruction sur elt</code></pre>

  <p>Pour parcourir tous les éléments d'une chaîne de caractères:</p>
    <pre><code class="language-python">for elmt in chaine:
  print(elt) # ou une quelconque instruction sur elt</code></pre>

    <h4>Particularité de Python</h4>

    <pre><code class="language-python">for lettre in chaine :
  if lettre in "aeiouy" :
  instructions</code></pre>

  <h4>La boucle while</h4>

  <pre><code class="language-python">while condition :
  instructions</code></pre>

  <p>Le mot clé <strong>break</strong> permet d'interrompre une boucle et d'exécuter le code qui suit la boucle. Le mot clé <strong>continue</strong> permet de sauter le tour de boucle courant puis de continuer à exécuter la boucle.</p>



<!-- ===== LES TABLEAUX ===== -->

<h3 id="py_tableau">Les tableaux</h3>

  <p>Les tableaux contiennent des éléments dont le nombre de bouge pas. On peut toutefois changer ces éléments. Un tableau est considéré comme un type élémentaire en Python.</p>

  <p>On peut créer un tableau de la manière suivante :</p>
  <pre><code class="language-python">tab = (element1, element2)</code></pre>

  <p>L'indice du 1er élément d'un tableau est 0.</p>

  <h4>Propriétés d'un tableau</h4>

  <table>
    <tr><th>Propriétés</th><th>Codes</th></tr>
    <tr><td>taille</td><td><pre>len(tab)</pre></td></tr>
    <tr><td>élément d'indice i</td><td><pre>tab[i]</pre></td></tr>
    <tr><td>dernier élément d'une liste</td><td><pre>tab[-1]</pre></td></tr>
    <tr><td>modifier l'élément d'indice i</td><td><pre>tab[i] = nouvelleValeur</pre></td></tr>
    <tr><td>indice d'un élément</td><td><pre>tab.index(element)</pre></td></tr>
  </table>



<!-- ===== LES LISTES ===== -->

<h3 id="py_liste">Les listes</h3>

  <p>Les listes sont des objets complexes en Python. Elles contiennent des éléments dont le nombre peut varier, mais l'indice du 1er élément est 0.</p>

  <p>On peut créer une liste de la manière suivante :</p>
  <pre><code class="language-python">liste = [element1, element2, element3]</code></pre>

  <p>En Python on peut stocker des éléments de différents types dans une liste.</p>
  <pre><code class="language-python">maListe = ["Antoine", 12, false]</code></pre>

  <p>En Python, l'appel à un indice ne figurant pas dans la liste conduit à une exception de la forme <em>IndexError: list index out of range</em>.</p>

  <p>Pour créer une liste vide</p>
  <pre><code class="language-python">maListe = list()</code></pre>

  <h4>Propriétés d'une liste</h4>

  <table>
    <tr><th>Propriétés</th><th>Codes</th></tr>
    <tr><td>taille</td><td><pre>len(maListe)</pre></td></tr>
    <tr><td>élément d'indice i</td><td><pre>maListe[i]</pre></td></tr>
    <tr><td>dernier élément d'une liste</td><td><pre>maListe[-1]</pre></td></tr>
    <tr><td>modifier l'élément d'indice i</td><td><pre>maListe[i] = nouvelleValeur</pre></td></tr>
    <tr><td>indice d'un élément</td><td><pre>maListe.index(element)</pre></td></tr>
    <tr><td>ajout d'un élément à la fin d'une liste</td><td><pre>maListe.append(element)</pre></td></tr>
    <tr><td>ajout d'un élément au début d'une liste'</td><td><pre>maListe.unshift(element)</pre></td></tr>
    <tr><td>ajout d'un élément à l'indice i</td><td><pre>maListe.insert(i, element)</pre></td></tr>
    <tr><td>concaténation de maListe1 et maListe2 enregistrée dans maListe1</td><td><pre>maListe1.extend(maListe2)</pre></td></tr>
    <tr><td>suppression du dernier élément et renvoi de sa valeur</td><td><pre>maListe.pop()</pre></td></tr>
    <tr><td>suppression de l'élément d'indice i</td><td><pre>del maListe[i]</pre></td></tr>
    <tr><td>suppression d'un élément défini par sa valeur, seul le 1er element de cette valeur est supprimé</td><td><pre>maListe.remove(element)</pre></td></tr>
    <tr><td>tri d'une liste d'entiers de façon ascendante (cette fonctionnalité modifie la liste d'origine)</td><td><pre>maListe.sort()</pre></td></tr>
    <tr><td>tri d'une liste d'entiers de façon descendante (cette fonctionnalité modifie la liste d'origine)</td><td><pre>maListe.sort(reverse=True)</pre></td></tr>
    <tr><td>inversion des éléments d'une liste</td><td><pre>maListe.reverse()</pre></td></tr>
  </table>

  <p>Une liste vide a pour taille 0. </p>

  <h4>Parcourir une liste</h4>

  <p>Si on souhaite afficher une liste sans mise en forme particulière, l'utilisation de <strong>print</strong> est suffisante.</p>
  <pre><code class="language-python">print(maListe)</code></pre>

  <p>On peut également afficher les éléments de maListe les uns à la suite des autres.</p>

  <pre><code class="language-python">for i in range(len(maListe)):
    print(maListe[i])</code></pre>

  <p>Python offre la possibilité de parcourir une liste sans référence aux indices, mais en utilisant un itérateur des éléments qui composent la liste. Ceci correspond à l'instruction <strong>forEach</strong> d'autres langages.</p>
  <pre><code class="language-python">for elmt in maListe:
    print(elmt)</code></pre>

  <p>Python offre deux autres possibilités pour afficher les éléments d'une liste :</p>

  <pre><code class="language-python">for value in enumerate(maListe):
    print(value)</code></pre>
  <pre><code class="language-python">for i, value in enumerate(maListe):
    print("indice {}, valeur {}".format(i,value))</code></pre>



  <!-- ====== UTILISATION AVANCEE DES LISTES ===== -->

  <h3 id="py_liste_avance">Utilisation avancée des listes</h3>

  <h4>Affectation par valeurs, affectation par référence</h4>

  <p>Il existe principalement deux manières de copier des listes en Python avec des fonctionnalités différentes. L'affectation
  par référence pointe vers l'adresse d'une liste, et donc tout changement opéré sur la copie affecte l'original. En revanche,
  l'affectation par valeurs copie les éléments d'une liste un à un, et donc tout changement opéré sur la copie n'a aucun effet
  sur l'original. L'affectation par référence consomme moins d'espace mémoire.</p>

  <pre><code class="language-python">maListe = ["a", "b", "c"]
copie_liste = maListe

copie_liste[1] = "hello"
print(maListe)</code></pre>

  <p>Le code ci-dessus qui copie la liste par référence affiche ['a', 'hello', 'c'], alors que le code ci-dessous qui
  copie la liste par valeurs affiche</p>

  <pre><code class="language-python">maListe = ["a", "b", "c"]
copie_liste = list(maListe)

copie_liste[1] = "hello"
print(maListe)</code></pre>

  <p>Ce dernier code est équivalent à :</p>

  <pre><code class="language-python">maListe = ["a", "b", "c"]
copie_liste = list()
for i in range(3):
    copie_liste[i] = maListe[i]

copie_liste[1] = "hello"
print(maListe)</code></pre>

  <h4>Les fonctions callback avec map</h4>

  <pre><code class="language-python">def carre(x):
    return x ** 2

maListe = [1, 2, 3, 4, 5]
print map(carre, maListe) # Affiche [1, 4, 9, 16, 25]</code></pre>

  <h4>Les fonction callback avec filter</h4>

  <pre><code class="language-python">def pair(x):
    return not bool(x % 2)

maListe = [1, 2, 3, 4, 5]
print filter(pair, maListe) # Affiche [2, 4]</code></pre>

  <h4>Les compréhensions de liste</h4>

  <p>Les compréhensions de liste permettent de modifier les éléments d'une liste selon une structure très particulière.
    Elles produisent des résultats semblables à ceux produits par le package Numpy mais dans le cas plus général que celui
    des nombres. Par exemple pour mettre les éléments au carré, on procède ainsi :</p>
  <pre><code class="language-python">nouvelleListe = [elt**2 for elt in maListe]</code></pre>

  <p>Les compréhensions de liste permettent également de filtrer les éléments d'une liste suivant une condition particulière. Par exemple pour rechercher les éléments pairs, on procède ainsi :</p>
  <pre><code class="language-python">nouvelleListe = [elt for elt in maListe if elt%2==0]</code></pre>

<p>Les compréhensions de liste sont préférables aux fonctions map et filter.</p>

  <h4>Conversion d'une liste en chaîne</h4>

  <p>La conversion d'une liste en chaîne et inversement est nécessaire pour effectuer certains traitements sur lse chaînes
    de caractères. En effet, les chaînes sont censées être de taille fixe et il n'existe pas de type Stringbuffer comme em Java par exemple.</p>

  <p>Pour convertir maListe en maChaine avec le séparateur "," :</p>

  <pre><code class="language-python">maListe = ["h", "e", "l", "l", "o"]
maChaine = "-".join(maListe)
print(maChaine # affiche h-e-l-l-o</code></pre>

  <p>Pour convertir maListe en maChaine sans séparateur :</p>

  <pre><code class="language-python">maListe = ["h", "e", "l", "l", "o"]
maChaine = "".join(maListe)
print(maChaine # affiche hello</code></pre>

  <p>Pour convertir maChaine en maListe :</p>

  <pre><code class="language-python">maListe = maChaine.split(", ")</code></pre>

  <p>L'utilisation de join avec des listes de compréhension permet l'affichage de plusieurs lignes dans une même chaìne.</p>

  <pre><code class="language-python">annuaire = [
  (1, "antoine"),
  (5, "celine"),
  (6, "herve")
]

print("\n".join(["%d pour %s" % (nbre, nom) for nbre, nom in annuaire]))</code></pre>

  <p>ce qui affiche : 1 pour antoine <br/>5 pour celine <br/>6 pour herve</p>




<!-- ===== LES DICTIONNAIRES ===== -->

<h3 id="py_dictionnaire">Les dictionnaires</h3>

  <p>Les dictionnaires sont constitués d'un ensemble de clés-valeurs, dans lequel il n'y a aucun ordre. Ils se construisent avec des accolades à la place des crochets et des virgules entre les éléments.</p>
  <pre><code class="language-python">dico ={
  "nom" : "Antoine",
  "prenom" : "Hervé";
}</code></pre>

  <p>Pour créer un dictionnaire vide :</p>
  <pre><code class="language-python">dico = dict()</code></pre>

  <p>Pour accéder à un élément du tableau, il ne faut plus appeler son indice qui n'existe pas mais appeler la clé de la façon suivante :</p>

  <pre><code class="language-python">dico.nom</code></pre>
  <p>On remarque donc qu'un tableau associatif n'est autre qu'un objet dans lequel les clés sont des propriétés qui possèdent des valeurs.</p>

  <p>Dans certains cas, on préfèrera appeler l'élément du tableau de la manière suivante :</p>
  <pre><code class="language-python">dico["nom"]</code></pre>

  <p>Pour ajouter un élément à la fin d'un tableau associatif, il suffit de créer cet élément :</p>
  <pre><code class="language-python">tabAsso["lieuNaissance"] = "Lausanne";</code></pre>

  <p>ou encore</p>
  <pre><code class="language-python">tabAsso.lieuNaissance = "Lausanne";</code></pre>

  <h4>Parcourir un dictionnaire</h4>

  <pre><code class="language-python">for cle in dico.keys():
  print(cle)

for valeur in dico.values():
  print(valeur)

for cle, valeur in dico.items():
    print("Clé {} -> Valeur {}".format(cle, valeur))</code></pre>

  <h4>Propriétés d'un dictionnaire</h4>

  <table>
    <tr><th>Propriétés</th><th>Codes</th></tr>
    <tr><td>taille</td><td><pre>len(liste)</pre></td></tr>
    <tr><td>élément d'indice i</td><td><pre>liste[i]</pre></td></tr>
    <tr><td>dernier élément d'une liste</td><td><pre>liste[-1]</pre></td></tr>
    <tr><td>modifier l'élément de clé key</td><td><pre>dico["key"] = "value"</pre></td></tr>
    <tr><td>indice d'un élément</td><td><pre>liste.index(element)</pre></td></tr>
    <tr><td>ajout d'un élément</td><td><pre>dico["key"] = "value"</pre></td></tr>
    <tr><td>suppression d'un élément défini par sa clé sans renvoi de sa valeur</td><td><pre>del dico["key"]</pre></td></tr>
    <tr><td>suppression d'un élément défini par sa clé et renvoi de sa valeur</td><td><pre>dico.pop("key")</pre></td></tr>
  </table>



  <!-- ===== LES FONCTIONS ===== -->

  <h3 id="py_fonction"> Les fonctions </h3>

  <p>La déclaration d'une fonction se réalise de la manière suivante :</p>
  <pre><code class="language-python">def nomFonction(parametre) :
  instructions
  return valeur</code></pre>

  <fieldset><legend>ATTENTION </legend>
    <p>En Python le type de retour de la fonction et le type des arguments ne sont pas spécifiés lors de la déclaration. Il est donc impossible de surcharger une fonction en Python.</p>
  </fieldset>

  <p>L'appel de la fonction se fait de la façon suivante :</p>
  <pre><code class="language-python">int valeur = nomFonction(12)</code></pre>

  <p>Lorsqu'il n'y a pas de valeur de retour, on parle de procédure :</p>
  <pre><code class="language-python">def nomProcedure(parametre) :
    instructions</code></pre>

  <p>L'appel de la procédure se fait de la façon suivante :</p>
  <pre><code class="language-python">nomProcedure(12);</code></pre>

  <p>Pour une fonction comme pour une procédure, on peut définir une valeur de paramètre par défaut si celle-ci n'est pas spécifiée, de la manière suivante :</p>
  <pre><code class="language-python">def nomFonction(parametre1, parametre2=43) :
  instructions
    return valeur</code></pre>

  <p>Bien que la valeur 43 soit attribuée par défaut au parametre2, celui-ci peut prendre n'importe quelle valeur qui lui soit attribuée.</p>

  <p>En Python, pour créer des fonctions attendant un nombre inconnu de paramètres, on utilise la syntaxe</p> <pre>def maFonction(*monTableau)</pre> <p>où <em>monTableau</em> est un tableau de parametres.</p>
    <h4>Documenter une fonction</h4>

    <p>En Python, l'ajout d'une <em>docstring</em> se fait sous le nom de la fonction, avec une indentation et 3 guillements. Elle peut s'étendre sur plusieurs lignes.</p>
    <pre><code class="language-python">def maFonction(parametre) :
  """documentation
  de maFonction"""
  instructions
  return</code></pre>

    <p>On appelle la documentation en utilisant l'instruction <strong>help(maFonction)</strong></p>

    <h4>Fonction anonyme</h4>

    <p>En Python, la fonction anonyme est appelée fonction <em>lambda</em>, mais le principe reste identique. On remplace dans ce cas le mot-clé <strong>def</strong> par <strong>lambda</strong> et on ne spécifie aucun nom pour la fonction créée.</p>
    <pre><code class="language-python">int maVariable = lambda x :
  2*x

   print(maVariable(3))</code></pre>

    <pre><code class="language-python">str maVariable = lambda parametre :
  "Bonjour ",parametre

   print(maVariable("Hervé"))</code></pre>

  <p>On remarque qu'une fonction lambda utilise une construction particuliére et transforme la variable <em>maVariable</em> en fonction.</p>

    <h4>Fonctions prédéfinies </h4>

    <table>
      <tr><th>Fonctions</th><th>Actions</th></tr>
      <tr><td>Math.min(2, 4)</td><td>donne le minimum des paramètres passés en arguments</td></tr>
      <tr><td>Math.random</td><td>génère un nombre aléatoire entre 0 et 1</td></tr>
    </table>

  <h4>Utilisation de la fonction callback en Python</h4>

  <p>Il s'agit d'une fonction qui sert de paramètre à une autre fonction.</p>

  <pre><code class="language-python">def maFonction(x):
  instruction

def autreFonction(maFonction, val):
  return maFonction(val)</code></pre>




  <!-- ===== LES EXCEPTIONS ===== -->

  <h3 id="py_exception">Les exceptions</h3>

  <p>Elles se construisent suivant les cas de différentes manières :</p>
  <pre><code class="language-python">try: # cas général
  instruction à tester
except:
  instruction en cas d'erreur
finally:
  instruction dans tous les cas

try: # variable non définie
  instruction à tester
except NameError as e:
  instruction en cas d'erreur

try: # le type de la variable est incompatible avec l'instruction
  instruction à tester
except TypeError as e:
  instruction en cas d'erreur

try: # division par 0
  instruction à tester
except ZeroDivisionError:
  instruction en cas d'erreur</code></pre>

  <p>Pour aller plus loin, la documentation Python officielle <a href="https://docs.python.org/3.5/library/index.html"><em>The Python Standard Library</em></a>.</p>



  <!-- ===== LES OBJETS EN JAVASCRIPT ===== -->

  <h3 id=""py_objet> Les objets en JavaScript </h3>

    <p>La création d'une classe requiert les mot-clés <strong>class</strong> et <strong>constructor()</strong>.</p>
    <pre><code class="language-python">class MaClasse{
  let nom;
  let prenom;

  constructor(nom, prenom){
    this.nom = nom;
    this.prenom = prenom;
  }

  uneMethode(parametre){
    instructions;
  }
}</code></pre>

  <p>L'instanciation d'un objet se fait de façon classique :</p>
  <pre><code class="language-python">let monObjet = new MaClasse("Charles", "Hervé");</code></pre>

  <h4>Particularité de JavaScript</h4>

  <p>JavaScript utilise des prototypes qui sont des liens vers d'autres objets pris en référence.</p>
  <pre><code class="language-python">let monObjet = new MaClasse(nom, prenom);

let unAutreObjet = Object.create(monObjet);</code></pre>

  <p>Dans l'exemple ci-dessus, l'objet <em>unAutreObjet</em> utilise le modèle de <em>monObjet</em> pour se construire qui lui-même est une instanciation de <em>maClasse</em>.</p>



<!-- ===== RANDOM ===== -->

<h3 id="py_random">Le package random</h3>

  <pre><code class="language-python">import random as rd</code></pre>

  <p>La méthode .random() génère un nombre pseudo-aléatoire compris entre 0 et 1.</p>

  <p>La méthode .randrange(5, 10, 2) génère un nombre pseudo-aléatoire compris entre 5 et 10 exclus, avec un écart de 2
  entre chaque valeur. Sans le 3ème paramètre, la valeur par défaut est 1.</p>

  <p>La méthode <strong>randint(4, 7)</strong> renvoie un entier compris entre 4 et 7 inclus.</p>

  <p>Pour remplir une liste de 10 éléments à l'aide de valeurs comprises entre 0 et 50 prises au hasard :</p>
  <pre><code class="language-python">liste = (rd.randrange(50) for i in range(10))</code></pre>

  <p>Pour remplir un tableau de 10 éléments à l'aide de valeurs comprises entre 0 et 50 prises au hasard :</p>
  <pre><code class="language-python">tableau = [rd.randrange(50) for i in range(10)]</code></pre>

  <p>La méthode choice(["a", "b", "c"]) renvoie un élément choisit au hasard de la liste ["a", "b", "c"].</p>

  <p>La méthode shuffle(liste) mélange les éléments d'une liste en modifiant cette liste. Elle ne renvoie rien.</p>



<!-- ===== MATH ===== -->

<h3 id="py_math">Le package math</h3>

  <pre><code class="language-python">from math import *</code></pre>

  <table>
    <tr><th>Instruction</th><th>Effet obtenu</th></tr>
    <tr><td>floor(x)</td><td>plus grand entier inférieur ou égal à x</td></tr>
    <tr><td>ceil(x)</td><td>plus petit entier supérieur ou égal à x</td></tr>
    <tr><td>trunc(x)</td><td>troncature de x</td></tr>
    <tr><td>fabs(x)</td><td>valeur absolue de x</td></tr>
    <tr><td>factorial(x)</td><td>factorielle de x. Lève une exception ValueError si x n'est pas entier ou si x est négatif</td></tr>
    <tr><td>fsum(maListe)</td><td>valeur exacte de la somme des valeurs d'une liste</td></tr>
    <tr><td>gcd(a, b)</td><td>pgdc de a et b</td></tr>
    <tr><td>exp(x)</td><td>exponentielle de x</td></tr>
    <tr><td>log1p(x)</td><td>logarithme en base e de x</td></tr>
    <tr><td>pow(x, y)</td><td>x puissance y, renvoie un float</td></tr>
    <tr><td>x**y</td><td>x puissance y, renvoie un int</td></tr>
    <tr><td>sqrt(x)</td><td>racine carrée de x</td></tr>
    <tr><td>acos(x)</td><td>arc cosinus de x en radians</td></tr>
    <tr><td>asin(x)</td><td>arc sinus de x en radians</td></tr>
    <tr><td>atan(x)</td><td>arc tangente de x en radians</td></tr>
    <tr><td>cos(x)</td><td>cosinus de x pour x en radians</td></tr>
    <tr><td>sin(x)</td><td>sinus de x pour x en radians</td></tr>
    <tr><td>tan(x)</td><td>tangente de x pour x en radians</td></tr>
    <tr><td>degrees(x)</td><td>convertit l'angle x de radians en degrés</td></tr>
    <tr><td>radians(x)</td><td>convertit l'angle x de degrés en radians</td></tr>
    <tr><td>acosh(x)</td><td>arc cosinus hyperbolique de x</td></tr>
    <tr><td>asinh(x)</td><td>arc sinus hyperbolique de x</td></tr>
    <tr><td>atanh(x)</td><td>arc tangente hyperbolique de x</td></tr>
    <tr><td>cosh(x)</td><td>cosinus hyperbolique de x</td></tr>
    <tr><td>sinh(x)</td><td>sinus hyperbolique de x</td></tr>
    <tr><td>tanh(x)</td><td>tangente hyperbolique de x</td></tr>
    <tr><td>pi</td><td>pi = 3,14</td></tr>
    <tr><td>e</td><td>e = 2,71</td></tr>
  </table>

  <p>En Python les angles sont exprimés en radian par défaut.</p>

  <p>pi et e sont les deux constantes mathématiques connues du package math.</p>



  <!-- ===== FRACTION ===== -->

  <h3 id="py_fraction">Le package fractions</h3>

  <pre><code class="language-python">from fractions import Fraction</code></pre>

  <p>Un objet de type Fraction est défini de la façon suivante : Fraction(numérateur, dénominateur). Une fois définie,
    une fraction est affichée systématiquement sous sa forme simplifiée.</p>

  <p>La classe Fraction accepte les opérations élémentaires +, -, *, / et permet de conserver une excellente précision de calcul.</p>



<!-- ===== NUMPY ===== -->

  <h3 id="py_numpy">Le package Numpy</h3>

  <pre><code class="language-python">import numpy as np</code></pre>

  <p>Numpy est utilisé pour manipuler des séries de nombres. En particulier, il permet de traiter des listes de nombres comme des tableaux de nombres.</p>

  <pre><code class="language-python">liste_numpy = np.array([10, 20, 30])
liste_divisee = liste_numpy/2</code></pre>

  <p>Numpy permet notamment de faire la somme des éléments de la liste :</p>
  <pre><code class="language-python">liste_numpy.sum()</code></pre>


<!-- ===== JSON ===== -->

<h3 id="py-json">Le package JSON</h3>

  <p>JSON est un format de stockage de données dans un fichier. JSON signifie JavaScript Object Notation.</p>
  <p>JSON ne se trouve pas nativement dans l'environnement de travail. Il est donc nécessaire de l'importer.</p>
  <pre>import json</pre>

  <p>Les données seront stockées suivant le format clé-valeur d'un dictionnaire. On peut par exemple avoir la structure suivante :</p>
  <pre><code class="language-python">{
cle:
    [
      {
        cle: valeur,
        cle: valeur,
        cle: valeur
      },
      {
        cle: valeur,
        cle: valeur,
        cle: valeur
      }
    ],
cle:
    [
      {
        cle: valeur,
        cle: valeur,
        cle: valeur
      },
      {
        cle: valeur,
        cle: valeur,
        cle: valeur
      }
    ]
}</code></pre>

  <p>Pour afficher ce fichier JSON, il faut d'abord le parcourir et le placer dans un dictionnaire qu'on pourra ensuite afficher :</p>
  <pre><code class="language-python"># on crée un dictionnaire local vide
data = dict()

# on ouvre le fichier json en lecture seule
with open("monFichier.json", "r") as file:
  # on transforme le fichier json en objet Python
  data = json.load(file)</code></pre>

  <p>Pour écrire sur un fichier JSON, il faut remplacer le fichier de destination par un dictionnaire <em>data</em>. <em>Attention</em>, il faut prendre soin de recopier dans le dictionnaire les valeurs inchangées du fichier JSON, car l'écriture dans le fichier JSON écrase les données présentes dans ce fichier.</p>
  <pre><code class="language-python">data = dict()
with open("monFichier.json", "w", encoding="utf-8") as file:
json.dump(data, file, indent=4)</code></pre>




  <!-- ==== CREER UN PACKAGE ===== -->

  <h3 id="py_creer_package">Créer un package</h3>

  <p>Un package Python est organisé en fichiers ou classes, qui sont regroupées dans des modules. Les noms des packages et des modules seront écrits en minuscule et peuvent contenir des underscore. La structure à adopter est la suivante :</p>
<pre>librairie // racine du package
  librairie/  // module Python
    __init__.py
    fichier.py
    main.py
    .gitignore
  setup.py</pre>

  <p>Le fichier .gitignore devra contenir :</p>
  <pre># compiled python modules
*.pyc

# setup tools distribution folder
/dist/

#python egg metadata, regenerated from source files by setuptools
/*.egg-info</pre>

  <p>Le fichier setup.py contient les commandes suivantes :</p>

  <pre><code class="language-python">from setuptools import setup

setup(name = "librairie",
  version = "1.0",
  description = "ma librairie",
  url = "http://github/librairie",
  author = "bob",
  author_email = "bob@gmail.com",
  licence = "xxx",
  packages = ['librairie'],
  install_requires = [ # list of dependancies
    'nomPakage',
  ],
  zip_safe = False)</code></pre>

 <p>L'installation d'un package en local sur Linux se fait avec la commande pip install librairie.</p>

<p>Pour publier un package sur PyPI, il faut utiliser la commande python setup.py register</p>


<!-- ===== PEP8 ===== -->

  <h3 id="py-pep">Respect du PEP8</h3>

  <p>Python Enhancement Proposal 8 requiert le respect des règles suivantes:</p>
  <ul>
    <li>une ligne doit contenir au maximum 80 caractères</li>
    <li>l'indentation doit contenir 4 espaces</li>
    <li>2 lignes vides au-dessus d'une classe</li>
    <li>les docstrings sont obligatoires pour les méthodes, les classes et les modules</li>
    <li>l'import d'un module ou d'un package doit se faire en début de code</li>
    <li>pas d'espace avant : mais un espace après</li>
    <li>un espace autour d'un opérateur</li>
    <li>un espace autour d'un = pour assigner une valeur à une variable</li>
    <li>pas d'espace autour d'un = pour assigner une valeur par défaut à un paramètre</li>
    <li>une instruction par ligne</li>
    <li>les commentaires sont écrits en anglais</li>
    <li>les modules s'écrivent en minuscule, avec un underscore si besoin</li>
    <li>les packets s'écrivent en minuscule sans underscore</li>
    <li>les classes ont une 1ère lettre en minuscule et peuvent avoir d'autres lettres en majuscule</li>
    <li>les méthodes s'écrivent en minuscule, avec underscore si besoin</li>
    <li>les variables s'écrivent en minuscule, avec underscore si besoin</li>
    <li>les constantes s'écrivent en majuscules, avec underscore si besoin</li>
  </ul>

<p>PyLint est un logiciel en ligne de commande permettant d'analyser le code en fonction des standards de PEP8.</p>

  <pre>pip install pylint
pylint fichier.py // lance l'analyse de fichier.py</pre>




  <p></p>

</section>

<footer>
  Stephane Robin
</footer>

</body>
</html>

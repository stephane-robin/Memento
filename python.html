<!DOCTYPE HTML>
<html>
<head>
  <title> Memento </title>
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="prism.css">
  <meta charset="utf-8">
</head>

<!-- script de gestion des couleurs de code -->
<script defer src="prism.js"></script>

<!-- script de gestion de l'apparition du contenu d'une section -->
<script type="text/javascript">
function affichageConditionnel(bouton, id) {
    var div = document.getElementById(id);
    if(div.style.display=="none") { // si le div est masqué, on l'affiche et on change le contenu du bouton
        div.style.display = "block";
        bouton.innerHTML = "-";
    } else { // s'il est visible, on le masque et on change le contenu du bouton
        div.style.display = "none";
        bouton.innerHTML = "+";
    }
}</script>

<body>

<!-- Image de présentation-->
<header>
  <div class="heroImage">
    <div class="heroTexte">
      <h2> Python </h2>
    </div>
  </div>
</header>

<!-- Bandeau et menu -->
<div id="bandeau">
  <div id="titre"> <h1> Memento </h1> </div>
  <nav>
    <div class="element"> <a href="html.html">HTML</a> </div>
    <div class="element"> <a href="css.html">CSS</a> </div>
    <div class="element"> <a href="javascript.html">JAVASCRIPT</a> </div>
    <div class="element"> <a href="python.html">PYTHON</a> </div>
    <div class="element"> <a href="java.html">JAVA</a> </div>
    <div class="element"> <a href="c.html">C</a> </div>
    <div class="element"> <a href="git.html">GIT</a> </div>
  </nav>
</div>

<section id="principal">

<p style="font-weight:bold"> Table des matières :</p>
  <ul>
    <li> <a href="#py_generalites">Généralités</a> </li>
    <li> <a href="#py_saisie">Les méthodes de communication</a> </li>
    <li> <a href="#py_import_package">Importer un package</a> </li>
    <li> <a href="#py_random">Les packages et modules essentiels</a> </li>
    <li> <a href="#py_creer_package">Créer un package avec Poetry</a> </li>
    <li> <a href="#py_pyenv">Gérer les versions de Python avec pyenv</a></li>
    <li> <a href="#py_venv">Créer des environnements de développement avec
      venv</a></li>
    <li> <a href="#py_pycharm">Utilisation de PyCharm dans un environnement
        particulier</a></li>
    <li> <a href="#py_variable">Les types de variables</a> </li>
    <li> <a href="#py_condition">Branchement conditionnel</a> </li>
    <li> <a href="#py_boucle">Les boucles</a> </li>
    <li> <a href="#py_chaine">Manipuler des chaînes de caractères</a> </li>
    <li> <a href="#py_tableau">Les tableaux</a> </li>
    <li> <a href="#py_liste">Les listes</a> </li>
    <li> <a href="#py_liste_avance">Utilisation avancée des listes</a> </li>
    <li> <a href="#py_dictionnaire">Les dictionnaires</a> </li>
    <li> <a href="#py_fonction">Les fonctions</a> </li>
    <li> <a href="#py_exception">La gestion des exceptions</a> </li>
    <li> <a href="#py_objet">La programmation objet</a> </li>
    <li> <a href="#py_pep">Respect du PEP8</a> </li>
  </ul>



  <!-- ===== GENERALITES ===== -->

  <h3 id="py_generalites"> Généralités </h3>

  <p>Les fichiers Python ont pour extension <em>.py</em></p>

  <p>Les commentaires sont indiqués à l'aide de <strong>#</strong> pour une seule ligne ou <strong>"""   """</strong> pour plusieurs lignes.</p>

  <p>En Python, les blocs ne sont pas encadrés par des <strong>{}</strong> comme dans la plupart des langages, ce sont les indentations qui indiquent à l'interpréteur le début et la fin d'un bloc. En conséquence, il est important de respecter toujours la même procédure d'indentation. On utilisera 4 espaces plutôt qu'une tabulation pour exprimer une indentation, ceci afin d'assurer une bonne portabilité du code.</p>

  <p>En Python, les mots clés à ne pas utiliser comme nom de variable ou de fonction sont les suivants:<br>
    <strong>and, or, del, from, none, as, global, nonlocal, try, assert, else, if, elif, not, while, for, except, import, with, class, true, false, in, pass, yield, continue, break, finally, is, raise, def, lambda, return</strong>.</p>

  <h4>Particularité d'une exécution de code au Terminal sous Linux et Mac</h4>

  <p>Pour connaître la version de Python utilisée : </p>
  <pre><code>python --version</code></pre>

  <p>Pour connaître le chemin vers le dossier Python :</p>
  <pre><code>which python</code></pre>

  <p>Il est souvent nécessaire de placer en début de code le chemin absolu de l'interpréteur (ici 3.7 représente la version de Python), et de préciser l'encodage UTF-8 :</p>
  <pre><code class="language-python">#!/usr/bin/env python3
# -*-coding:Utf-8 -*</code></pre>

  <p>Pour télécharger l'environnement de travail Anaconda, il faut d'abord télécharger Anaconda pour Linux, vérifier le sha avec la commande :</p>
  <pre><code>sha256sum [nom_fichier_telecharge]</code></pre>

  <p>puis exécuter le fichier d'installation :</p>
  <pre><code>bash Anaconda-[version]-Linux-x86_64.sh</code></pre>

  <p>Finalement, il est possible de tester l'installation en utilisant :</p>
  <pre><code>conda list</code></pre>

  <p>Lors de la création d'un projet, il faut spécifier l'environnement dans lequel on travaille, comme par exemple virtualenv ou conda.</p>

  <p>L'installation de l'éditeur JetBrains PyCharm-community se fait sur Linux grâce à l'instruction au Terminal :</p>
  <pre><code>sudo snap install pycharm-community --classic</code></pre>

  <p>Une fois qu'on a installé Anaconda, l'exécution se fait grâce à l'instruction :</p>
  <pre><code>anaconda-navigator</code></pre>

  <p>Pour mettre à jour Anaconda :</p>
  <pre><code>conda update conda</code></pre>

  <p>Pour connaître l'emplacement de conda :</p>
  <pre><code>which conda</code></pre>

  <h4>Particularité du système Windows</h4>

  <p>Il est nécessaire de mettre en pause le programme en fin d'exécution afin de pouvoir lire le résultat. Préciser l'encodage peut s'avérer nécessaire sous Windows.</p>
  <pre><code class="language-python"># -*-coding:Latin-1 -*
import os
# le programme se trouve ici
os.system("pause")</code></pre>

<h4>Hello world</h4>

<p>Commençons par le traditionnel "Hello world". Contrairement à beaucoup de langages, Python n'utilise pas de <strong>;</strong> à la fin de chaque instruction. Il le remplace par un retour à la ligne. Notons que les accolades symbolisant un bloc sont remplacées par une indentation.</p>
  <pre><code class="language-javascript">print("Hello World");</code></pre>

<p>A noter que <em>print</em> entraîne systématiquement un retour à la ligne, contrairement à certains autres langages où il faut rajouter ln
pour aller à la ligne. Pour éviter un retour à la ligne, on utilise l'instruction print("hello", end = "")</p>





  <!-- ===== CHANGER LES VERSIONS DE PYTHON ===== -->

  <h3 id="py_version">Gérer les versions de Python avec pyenv</h3>

  <p>Pour connaître la version active de Python :</p>
  <p>python --version</p>

  <p>Pour connaître toutes les versions disponibles au téléchargement de Python3.6 à 3.8 :</p>
  <pre><code class="language-svg">pyenv install --list | grep " 3\.[678]"</code></pre>

  <p> Toutes les versions s'installent dans un fichier .pyenv/versions/, qui vient s'insérer dans le PATH au coeur du
    système, et non pas directement dans un  environnement de développement. Ainsi, un environnement peut utiliser une
    version particulière de Python en pointant vers l'adresse de stockage de la version, sans qu'elle soit incorporée à
    cet environnement. Pour installer la version 3.7.2 en particulier :</p>
  <pre><code class="language-svg">pyenv install -v 3.7.2</code></pre>

  <p>Pour supprimer la version 2.7.15 de l'ordinateur :</p>
  <pre><code class="language-svg">pyenv uninstall 2.7.15</code></pre>
  <p>Attention de travailler avec une version 3 de Python et de ne pas supprimer la version 2 système de Python livrée
    d'usine et servant au fonctionnement de l'ordinateur.</p>

  <p>Il est important de bien connaître la version de Python utilisée avant de procéder à tout changement dans un
    environnement de développement, car chaque version accepte des dépendances différentes.</p>

  <p>Pour connaître toutes les versions disponibles sur l'ordinateur (la version active est précédée d'une *) :</p>
  <pre><code class="language-svg>">pyenv versions</code></pre>

  <p>Pour connaître l'adresse de la version de Python utilisée :</p>
  <pre><code class="language-svg">which python # ou encore
pyenv which python</code></pre>

  <p>Pour changer la version de Python en local dans l'environnement de développement :</p>
  <pre><code class="language-svg">pyenv local 3.7.1</code></pre>

  <p>Pour changer la version de Python pour tout l'ordinateur :</p>
  <pre><code class="language-svg">pyenv global 2.7.15</code></pre>

  <p>Pour revenir à la version système :</p>
  <pre><code class="language-svg">pyenv global system</code></pre>




  <!-- ===== CREER DES ENVIRONNEMENTS DE TRAVAIL ===== -->

  <h3 id="py_env">Créer des environnements de développement avec venv</h3>

  <p>Il est nécessaire de travailler dans des environnements virtuels pour isoler les dépendances de chaque projet Python.
    Pour cela, on utilise le module venv compris dans la librairie standard de Python3. Il est également possible d'utiliser
    virtualenv à la place de venv, mais ce dernier est déjà compris dans les versions de Python supérieures à 3.5 et ne
    nécessite donc pas d'installer virtualenv comme une dépendance.</p>

  <p>Au terminal, on crée tout d'abord le dossier qui va contenir mes environnements virtuels, puis on se place dedans :</p>

  <pre><code class="language-svg">mkdir environnements
cd environnements</code></pre>

  <p>On crée maintenant un nouvel environnement au sein du dossier environnements :</p>

  <pre><code class="language-svg">python3 -m venv mon_env</code></pre>

  <p>Pour visualier la structure de mon_env il suffit de taper tree dans le dossier courant.</p>

  <img src="venv.png">

  <p>bin contient les fichiers qui interagissent avec l'environnement virtuel, include contient les en-têtes C qui compilent
    les packages Python, lib contient une copie de la version Python avec un dossier de packages dans lequel sont installées
    toutes les dépendances.</p>

  <p>Il est maintenant nécessaire d'activer l'environnement virtuel comme environnement de travail. Pour cela, il faut se
    placer dans le dossier environnements et taper au Terminal :</p>

  <pre><code class="language-svg">source mon_env/bin/activate</code></pre>

  <p>A partir de maintenant, les commandes saisies ont une action dans l'environnement. On remarque que l'environnement
    est actif, car devant le prompt du Terminal apparaît (mon_env)$.</p>

  <p>Pour désactiver cet environnemnt virtuel, il suffit de taper :</p>

  <pre><code class="language-svg">deactivate</code></pre>

  <p>Pour installer un module dans l'environnement, il faut d'abord se rendre dans l'environnement puis :</p>
  <pre><code class="language-svg">cd mon_env
pip3 install nom_package</code></pre>

  <p>Pour voir la liste de tous les modules installés :</p>
  <pre><code class="language-svg">pip3 freeze</code></pre>

  <p>Pour utiliser une version particulière de Python dans l'environnement, il faut d'abord installer cette version sur
    l'ordinateur, puis se rendre dans l'environnement et définir cette version comme la version locale :</p>
  <pre><code class="language-svg">pyenv install 3.8.0
cd mon_env
pyenv local 3.8.0</code></pre>



  <!-- ===== UTILISATION DE PYCHARM DANS UN ENVIRONNEMENT ===== -->

  <h3 id="py_pycharm">Utilisation de PyCharm dans un environnement particulier</h3>

  <p>PyCharm crée automatiquement un dossier PyCharmProjects dans lequel il va ranger les différents projets. On peut
    alors choisir l'interpréteur parmi ceux proposés, et en fonction de ce qui a été installé (conda, virtualenv, une version
    particulière de Python ...). Pour cela, après avoir ouvert PyCharm, sélectionné le projet, puis File -> Settings ->
    Project Interpreter.</p>

  <p>On peut également utiliser un environnement lié à un projet déjà existant. Pour cela, on commence par créer un dossier
    dans lequel on crée l'environnement de développement avec venv, puis on ouvre PyCharm, on ouvre le projet existant,
    File -> Settings -> Project Interpreter. PyCharm devrait avoir reconnu l'environnement de travail et pointer directement
    vers la bonne version de Python, avoir les bons packages déjà installés. Si ces packages font défaut lors de l'exécution,
    l'erreur liée au package donne lieu à un signal rouge et un menu qui permet de confirmer l'installation du package.</p>





  <!-- ======== LES METHODES DE COMMUNICATION ========= -->

  <h3 id="py_communication">Les méthodes de communication</h3>

  <h4>Afficher une valeur</h4>

  <p>La fonction print() permet d'afficher une chaîne de caractères et accepte les paramètres suivants :</p>
    <ul>
  <li>end='-' pour préciser ce qu'il faut afficher à la fin de la chaine ou pour afficher sur une même ligne avec end=''</li>
  <li>sep='-' pour préciser le séparateur entre plusieurs chaînes.</li>
</ul>

  <p>Python accepte les template litteral, suivant trois formats du plus ancien au plus moderne :</p>

  <pre><code class="language-python">name = "Bob"
"Hello %s" % name</code></pre>

  <pre><code class="language-python">name = "Bob"
"Hello {}".format(name)</code></pre>

  <pre><code class="language-python">name = "Bob"
f"Hello {name}"</code></pre>

  <p>L'intérêt du template litteral, outre sa structure simple, est qu'il n'est pas nécessaire de transformer name en
  string dans le cas où il s'agit d'un float pour pouvoir le concaténer avant de l'afficher. Cela simplifie donc la
  compréhension du code.</p>


  <h4>Saisie d'une valeur par l'utilisateur</h4>

  <pre><code class="language-python">nom = input("Quel est votre nom ?");
print("Bonjour ",nom);</code></pre>

  <p></p>

  <fieldset><legend>ATTENTION </legend>
    <p>La valeur saisie est systématiquement de type <em>String</em>. Il convient donc de la transformer en nombre le cas échéant.</p>
  </fieldset>

  <pre><code class="language-python">age = int(input("Quel est votre âge ?"))
print("Dans deux ans vous aurez ", age+2)</code></pre>

env -p /home/stephane/3.6.5



<!-- ===== IMPORTER UN PACKAGE ===== -->

<h3 id="py_import_package">Installer et importer un package</h3>

  <p>Pour installer un package, si la version de Python par défaut est Python3, on utilise l'instruction pip en ligne de
    commande, si la version de Python par défaut est Python2, on utilise l'instruction pip3 en ligne de commande pour forcer
    l'ordinateur à pointer vers Python3 :</p>
  <pre><code class="language-python">pip install nom_package</code></pre>

  <p>De la même façon, pour désinstaller un package :</p>
  <pre><code class="language-python">pip uninstall nom_package</code></pre>

  <p>Ensuite, pour importer un package dans le code, on peut utiliser l'instruction :</p>
  <pre><code class="language-python">import nomPackage</code></pre>

  <p>Dans ce cas, il faudra appeler chaque fonction en utilisant <em>nomPackage</em> comme préfixe.</p>
  <pre><code class="language-python">nomPackage.maFonction(5)</code></pre>

  <p>Pour éviter cela, On peut importer un package en précisant un préfixe :</p>
  <pre><code class="language-python">import nomPackage as p</code></pre>

<p>Chaque fonction du package sera ensuite appelée avec ce même préfixe <em>np</em>.</p>
  <pre><code class="language-python">p.maFonction(5)</code></pre>

<p>Lorsqu'il n'y a aucun risque de confusion entre les fonctions de différents packages, on peut utiliser l'instruction
  suivante qui évite d'ajouter un préfixe à chaque instruction. C'est pratique dans un script, mais déconseillé dans un
  code complexe pour réduire les erreurs et accroître la scalabilité du code.</p>

  <pre><code class="language-python">from nomPackage import *</code></pre>

  <p>Pour importer uniquement un module d'un package, par exemple :</p>

  <pre><code class="language-python">import matplotlib.pyplot as plt</code></pre>

  <h4>Particularité Python pour l'importation d'un package</h4>

  <p>Pour éviter qu'une méthode main() ne se lance à l'importation, on peut utiliser une condition qui lance la méthode uniquement si elle est appelée :</p>

  <pre><code class="language-python">if __name__ == "__main__":
  main()</code></pre>

  <p>Parmi les packages importants, on trouve Matplotlib utilisé pour les graphiques, Numpy utilisé pour manipuler des séries de nombres, Pandas utilisé pour utiliser des données sous une forme de tableur.</p>



    <!-- ===== LES MODULES ESSENTIELS  ===== -->

    <h4>Les packages et modules essentiels</h4>

    <p>Python étant parcitulièrement utilisé dans le milieu scientifique et
      mathématique, le module math ainsi que le module numpy sont essentiels</p>

    <h4>Le module random</h4>

    <pre><code class="language-python">import random as rd</code></pre>

    <p>La méthode .random() génère un nombre pseudo-aléatoire compris entre 0 et 1.</p>

    <p>La méthode .randrange(5, 10, 2) génère un nombre pseudo-aléatoire compris entre 5 et 10 exclus, avec un écart de 2
      entre chaque valeur. Sans le 3ème paramètre, la valeur par défaut est 1.</p>

    <p>La méthode <strong>randint(4, 7)</strong> renvoie un entier compris entre 4 et 7 inclus.</p>

    <p>Pour remplir une liste de 10 éléments à l'aide de valeurs comprises entre 0 et 50 prises au hasard :</p>
    <pre><code class="language-python">liste = (rd.randrange(50) for i in range(10))</code></pre>

    <p>Pour remplir un tableau de 10 éléments à l'aide de valeurs comprises entre 0 et 50 prises au hasard :</p>
    <pre><code class="language-python">tableau = [rd.randrange(50) for i in range(10)]</code></pre>

    <p>La méthode choice(["a", "b", "c"]) renvoie un élément choisit au hasard de la liste ["a", "b", "c"].</p>

    <p>La méthode shuffle(liste) mélange les éléments d'une liste en modifiant cette liste. Elle ne renvoie rien.</p>


    <h4>Le module math</h4>

    <pre><code class="language-python">from math import *</code></pre>

    <table>
      <tr><th>Instruction</th><th>Effet obtenu</th></tr>
      <tr><td>floor(x)</td><td>plus grand entier inférieur ou égal à x</td></tr>
      <tr><td>ceil(x)</td><td>plus petit entier supérieur ou égal à x</td></tr>
      <tr><td>trunc(x)</td><td>troncature de x</td></tr>
      <tr><td>fabs(x)</td><td>valeur absolue de x</td></tr>
      <tr><td>factorial(x)</td><td>factorielle de x. Lève une exception ValueError si x n'est pas entier ou si x est négatif</td></tr>
      <tr><td>fsum(maListe)</td><td>valeur exacte de la somme des valeurs d'une liste</td></tr>
      <tr><td>gcd(a, b)</td><td>pgdc de a et b</td></tr>
      <tr><td>exp(x)</td><td>exponentielle de x</td></tr>
      <tr><td>log1p(x)</td><td>logarithme en base e de x</td></tr>
      <tr><td>pow(x, y)</td><td>x puissance y, renvoie un float</td></tr>
      <tr><td>x**y</td><td>x puissance y, renvoie un int</td></tr>
      <tr><td>sqrt(x)</td><td>racine carrée de x</td></tr>
      <tr><td>acos(x)</td><td>arc cosinus de x en radians</td></tr>
      <tr><td>asin(x)</td><td>arc sinus de x en radians</td></tr>
      <tr><td>atan(x)</td><td>arc tangente de x en radians</td></tr>
      <tr><td>cos(x)</td><td>cosinus de x pour x en radians</td></tr>
      <tr><td>sin(x)</td><td>sinus de x pour x en radians</td></tr>
      <tr><td>tan(x)</td><td>tangente de x pour x en radians</td></tr>
      <tr><td>degrees(x)</td><td>convertit l'angle x de radians en degrés</td></tr>
      <tr><td>radians(x)</td><td>convertit l'angle x de degrés en radians</td></tr>
      <tr><td>acosh(x)</td><td>arc cosinus hyperbolique de x</td></tr>
      <tr><td>asinh(x)</td><td>arc sinus hyperbolique de x</td></tr>
      <tr><td>atanh(x)</td><td>arc tangente hyperbolique de x</td></tr>
      <tr><td>cosh(x)</td><td>cosinus hyperbolique de x</td></tr>
      <tr><td>sinh(x)</td><td>sinus hyperbolique de x</td></tr>
      <tr><td>tanh(x)</td><td>tangente hyperbolique de x</td></tr>
      <tr><td>pi</td><td>pi = 3,14</td></tr>
      <tr><td>e</td><td>e = 2,71</td></tr>
    </table>

    <p>En Python les angles sont exprimés en radian par défaut.</p>

    <p>pi et e sont les deux constantes mathématiques connues du package math.</p>


    <h4>Le module fractions</h4>

    <pre><code class="language-python">from fractions import Fraction</code></pre>

    <p>Un objet de type Fraction est défini de la façon suivante : Fraction(numérateur, dénominateur). Une fois définie,
      une fraction est affichée systématiquement sous sa forme simplifiée.</p>

    <p>La classe Fraction accepte les opérations élémentaires +, -, *, / et permet de conserver une excellente précision de calcul.</p>


    <h3>Le module Numpy</h3>

    <pre><code class="language-python">import numpy as np</code></pre>

    <p>Numpy est utilisé pour manipuler des séries de nombres. En particulier, il permet de traiter des listes de nombres comme des tableaux de nombres.</p>

    <pre><code class="language-python">liste_numpy = np.array([10, 20, 30])
liste_divisee = liste_numpy/2</code></pre>

    <p>Numpy permet notamment de faire la somme des éléments de la liste :</p>
    <pre><code class="language-python">liste_numpy.sum()</code></pre>


    <h4>Le package MatPlotLib</h4>

    <p>MatPlotLib est utilisé pour représenter des données en deux dimensions, i.e. pour créer des schémas, des graphiques
      et des spectres. Ce package comprend notamment le module Pyplot qui permet de créer des graphiques en couleur.</p>

    <h4>Le package JSON</h4>

    <p>JSON est un format de stockage de données dans un fichier. JSON signifie JavaScript Object Notation.</p>
    <p>JSON ne se trouve pas nativement dans l'environnement de travail. Il est donc nécessaire de l'importer.</p>
    <pre>import json</pre>

    <p>Les données seront stockées suivant le format clé-valeur d'un dictionnaire. On peut par exemple avoir la structure suivante :</p>
    <pre><code class="language-svg">dico = {
    'collège_St_André':
        [
            {
                'nom': 'Fremon',
                'prenom': 'Antoine',
                'pseudo': 'toto',
                'moyennes':
                    {
                        '6ème': 14,
                        '5ème': 14,
                        '4ème': 13,
                        '3ème': 11.5
                    }
            },
            {
                'nom': 'Sabert',
                'prenom': 'CLementine',
                'pseudo': 'clea'
                'moyennes':
                    {
                        '6ème': 12,
                        '5ème': 13,
                        '4ème': 12,
                        '3ème': 11
                    }
            }
        ],
        #
        'collège_bernard':
        [
            {
                'nom': 'Carmeni',
                'prenom': 'Loui',
                'pseudo': 'lolo',
                'moyennes':
                    {
                        '6ème': 19,
                        '5ème': 16,
                        '4ème': 16,
                        '3ème': 14
                    }
            },
            {
                'nom': 'Florimar',
                'prenom': 'Capucine',
                'pseudo': 'cap'
                'moyennes':
                    {
                        '6ème': 18,
                        '5ème': 18,
                        '4ème': 17,
                        '3ème': 18
                    }
            }
        ]
}</code></pre>

    <p>Pour afficher ce fichier JSON, il faut d'abord le parcourir et le placer dans un dictionnaire qu'on pourra ensuite afficher :</p>
    <pre><code class="language-python"># on crée un dictionnaire local vide
data = dict()

# on ouvre le fichier json en lecture seule
with open("monFichier.json", "r") as file:
  # on transforme le fichier json en objet Python
  data = json.load(file)</code></pre>

    <p>Pour écrire sur un fichier JSON, il faut remplacer le fichier de destination par un dictionnaire <em>data</em>. <em>Attention</em>, il faut prendre soin de recopier dans le dictionnaire les valeurs inchangées du fichier JSON, car l'écriture dans le fichier JSON écrase les données présentes dans ce fichier.</p>
    <pre><code class="language-python">data = dict()
with open("monFichier.json", "w", encoding="utf-8") as file:
json.dump(data, file, indent=4)</code></pre>




    <!-- ==== CREER UN PACKAGE ===== -->

    <h3 id="py_creer_package">Créer un package</h3>

    <p>Un package Python est organisé en fichiers ou classes, qui sont regroupées dans des modules. Les noms des packages et des modules seront écrits en minuscule et peuvent contenir des underscore. La structure à adopter est la suivante :</p>
    <pre>librairie // racine du package
  librairie/  // module Python
    __init__.py
    fichier.py
    main.py
    .gitignore
  setup.py</pre>

    <p>Le fichier .gitignore devra contenir :</p>
    <pre># compiled python modules
*.pyc

# setup tools distribution folder
/dist/

#python egg metadata, regenerated from source files by setuptools
/*.egg-info</pre>

    <p>Le fichier setup.py contient les commandes suivantes :</p>

    <pre><code class="language-python">from setuptools import setup

setup(name = "librairie",
  version = "1.0",
  description = "ma librairie",
  url = "http://github/librairie",
  author = "bob",
  author_email = "bob@gmail.com",
  licence = "xxx",
  packages = ['librairie'],
  install_requires = [ # list of dependancies
    'nomPakage',
  ],
  zip_safe = False)</code></pre>

    <p>L'installation d'un package en local sur Linux se fait avec la commande pip install librairie.</p>

    <p>Pour publier un package sur PyPI, il faut utiliser la commande python setup.py register</p>





    <!-- ===== CREER UN PACKAGE ===== -->

    <h3 id="py_package">Créer un package avec Poetry</h3>

    <p>Il est possible de créer manuellement les fichiers build, manifestes et dépendances en utilisant pip ou conda.
      Toutefois, la gestion des compatibilités des dépendances n'est pas toujours assurée et la publication sur PyPI peut
      s'avérer impossible. Poetry est un outil complet ... Pour installer Poetry il faut écrire le script en ligne de commande :</p>

    <pre><code class="language-python">curl -sSL https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py | python3</code></pre>

    <p>Ce script installe Poetry et il est nécessaire de relancer le Terminal pour modifier automatiquement le system PATH. On peut vérifier la bonne installation avec la
      commande :</p>

    <pre><code class="language-python">poetry --version</code></pre>

    <p>Pour générer un package, il ne faut pas créer de répertoire vide mais écrire directement :</p>

    <pre><code class="language-python">poetry new mon_package</code></pre>

    <p>qui crée le package dans un répertoire du même nom.</p>

    <p>La structure du package ressemble ainsi à ceci :</p>

    <img src="poetry.png" alt="poetry"/>

    <p>Il faut ensuite ajouter des dépendances au fichier .toml dont la version sera enregistrée dans un fichier .lock. Bien
      qu'il soit possible de les ajouter manuellement, il est préférable d'utiliser la commande suivante qui gère la compatibilité
      des dépendances :</p>

    <pre><code class="language-python">poetry add un_module</code></pre>






    <!-- ===== LES VARIABLES ===== -->

<h3 id="py_variable">Les types de variables</h3>

  <p>Python est un langage à typage dynamique, i.e. qu'il identifie lui-même les types de variables et autorise les changements de type. La déclaration des variables n'est donc pas nécessaire. L'instruction <strong>int(chaine)</strong> permet de transformer un <em>String</em> en nombre <em>si cela est possible</em> alors que l'instruction <strong>str(nombre)</strong> permet de transformer un nombre en <em>String</em>.</p>
  <p>Par ailleurs, Python est un langage fortement typé, i.e. qu'il ne convertit pas automatiquement les types de variables, mais requiert une instruction spécifique. Ainsi, la concaténation d'un <em>String</em> avec un entier lève une exception et ne transforme pas l'entier en <em>String</em>.</p>
  <p>Pour tester le type d'une variable, on utilise l'instruction <strong>type(maVariable)</strong>. Cette instruction lève une exception si maVariable n'existe pas. En revanche, elle renvoie le type si maVariable a été déclarée mais reste vide.</p>

  <table>
    <tr><th>Types</th><th>Mots-clés</th></tr>
    <tr><td>entier</td><td>int</td></tr>
    <tr><td>nombre décimal</td><td>float</td></tr>
    <tr><td>nombre complexe</td><td>complex</td></tr>
    <tr><td>chaîne de caractères</td><td>str</td></tr>
    <tr><td>booléen</td><td>bool</td></tr>
  </table>

  <p>Les booléens prennent les valeurs <strong>True</strong> et <strong>False</strong>.</p>
  <p>Il n'existe pas de type StringBuffer comme en Java pour représenter les chaînes de caractères modifiables.</p>

  <h4>Particularité de Python</h4>

  <p>Python permet de permuter simplement les valeurs de deux variables sans passer par une troisième.</p>
  <pre><code class="language-python">a = 2
b = 5
a, b = b, a</code></pre>

  <h4> Les principales opérations </h4>

  <table>
    <tr><th>Opérations</th><th>Symboles</th></tr>
    <tr><td>addition</td><td>+</td></tr>
    <tr><td>soustraction</td><td>-</td></tr>
    <tr><td>multiplication</td><td>*</td></tr>
    <tr><td>division</td><td>/</td></tr>
    <tr><td>modulo</td><td>%</td></tr>
    <tr><td>partie entière d'une division</td><td>//</td></tr>
    <tr><td>concaténation</td><td>+</td></tr>
    <tr><td>affectation</td><td>=</td></tr>
    <tr><td>égalité</td><td>==</td></tr>
    <tr><td>incrémentation</td><td>++</td></tr>
    <tr><td>décrémentation</td><td>--</td></tr>
    <tr><td>ET logique</td><td>and</td></tr>
    <tr><td>OU logique</td><td>or</td></tr>
    <tr><td>NON logique</td><td>! ou  not</td></tr>
  </table>

  <h4>Les opérateurs de comparaison</h4>

  <table>
    <tr><th>Signification</th><th>Opérateurs</th></tr>
    <tr><td>égalité</td><td>==</td></tr>
    <tr><td>égalité (valeur et type)</td><td>===</td></tr>
    <tr><td>différent</td><td>!=</td></tr>
    <tr><td>inférieur</td><td><</td></tr>
    <tr><td>inférieur ou égal</td><td><=</td></tr>
    <tr><td>supérieur</td><td>></td></tr>
    <tr><td>supérieur ou égal</td><td>>=</td></tr>
  </table>

  <h4>Les constantes</h4>

  <p>Les constantes n'existent pas en Python. On utilise généralement des variables globales qu'on ne modifie pas.</p>




  <!-- ===== BRANCHEMENT CONDITIONNEL ===== -->

  <h3 id="py_condition">Branchement conditionnel</h3>

    <h4>La condition if</h4>

    <pre><code class="language-python">if condition :
  instructions
else :
instructions</code></pre>

    <h4>Particularités de Python</h4>

    <p>L'instruction <strong>elif</strong> est la contraction de l'instruction <strong>else if</strong>.</p>

    <pre><code class="language-python">if condition :
  instructions
elif condition :
  instructions
else :
  instructions</code></pre>
    
    <p>L'instruction <strong>switch</strong> n'existe pas de façon native en Python.</p>



  <!-- ===== LES BOUCLES ===== -->

  <h3 id="py_boucle"> Les boucles </h3>

  <h4>La boucle for</h4>

  <p>Pour une répétition allant de 0 à 4 :</p>
    <pre><code class="language-python">for i in range(0, 5):
  instructions</code></pre>

  <p>Pour parcourir tous les éléments d'une liste ou d'un tableau:</p>
  <pre><code class="language-python">for elmt in liste:
  print(elt) # ou une quelconque instruction sur elt</code></pre>

  <p>Pour parcourir tous les éléments d'une chaîne de caractères:</p>
    <pre><code class="language-python">for elmt in chaine:
  print(elt) # ou une quelconque instruction sur elt</code></pre>

    <h4>Particularité de Python</h4>

    <pre><code class="language-python">for lettre in chaine :
  if lettre in "aeiouy" :
  instructions</code></pre>

  <h4>La boucle while</h4>

  <pre><code class="language-python">while condition :
  instructions</code></pre>

  <p>Le mot clé <strong>break</strong> permet d'interrompre une boucle et d'exécuter le code qui suit la boucle. Le mot clé <strong>continue</strong> permet de sauter le tour de boucle courant puis de continuer à exécuter la boucle.</p>





    <!-- ===== MANIPULER DES CHAINES DE CARACTERES ===== -->

    <h3 id="py_chaine">Manipuler des chaînes de caractères</h3>

    <p>L'indice du 1er caractère d'une chaîne est 0. Pour échapper une apostrophe ou un guillemet, on utilise le signe <strong>\</strong>.<p>

    <table>
      <tr><th>Propriétés</th><th>Codes</th></tr>
      <tr><td>taille</td><td><pre>len(chaine)</pre></td></tr>
      <tr><td>élément d'indice i</td><td><pre>chaine[i]</pre></td></tr>
      <tr><td>dernier élément</td><td><pre>chaine[-1]</pre></td></tr>
      <tr><td>convertir en minuscules</td><td><pre>chaine.lower()</pre></td></tr>
      <tr><td>convertir en majuscules</td><td><pre>chaine.upper()</pre></td></tr>
      <tr><td>mettre en majuscule le 1er caractère d'une chaîne</td><td><pre>chaine.capitalize()</pre></td></tr>
      <tr><td>nombre de "d" dans la chaîne</td><td><pre>chaine.count("d")</pre></td></tr>
      <tr><td>remplacement de "d" par "a"</td><td><pre>chaine.replace("d", "a")</pre></td></tr>
      <tr><td>enlever les espaces au début et à la fin d'une chaine</td><td><pre>chaine.strip()</pre></td></tr>
      <tr><td>extrait une sous-chaîne, comprenant la lettre d'indice 3 jusqu'à la lettre d'indice 5 incluse</td><td><pre>chaine[3:6]</pre></td></tr>
      <tr><td>extrait une sous-chaîne, comprenant la lettre d'indice 3 jusqu'à la lettre d'indice 5 incluse</td><td><pre>chaine[3:6]</pre></td></tr>
      <tr><td>comparaison</td><td>===</td></tr>
      <tr><td>concaténation</td><td>+</td></tr>
      <tr><td>retour à la ligne</td><td>\n</td></tr>
      <tr><td>tabulation</td><td>\t</td></tr>
      <tr><td>transformer une chaîne en liste élément par élément</td><td><pre>liste = chaine.split()</pre></td></tr>
      <tr><td>transformer une chaîne avec le séparateur - en liste</td><td><pre>liste = chaine.split("-");</pre></td></tr>
      <tr><td>transformer une liste en chaîne contenant le séparateur - </td><td><pre>chaine = "-".join(maListe)</pre></td></tr>
      <tr><td>recherche de "non" dans une chaine. Renvoie -1  si le caractère recherché ne se trouve pas dans la chaîne</td><td><pre>chaine.indexOf("non")</pre></td></tr>
      <tr><td>retour à la ligne</td><td>\n</td></tr>
      <tr><td>test si le contenu de la chaîne est numérique. Renvoie un booléen</td><td><pre>chaine.isnumeric()</pre></td></tr>
    </table>

    <p>L'utilisation d'un indice qui n'existe pas dans la chaîne lève une exception de type <em>IndexError</em>.</p>
    <p>Il n'est pas possible de modifier un caractère d'une chaîne de la façon suivante <em>chaine[4] = "Antoine"</em>. Il s'agit en fait d'une protection des chaînes qui pourront être modifiées par instruction explicite du développeur.</p>

    <p>Python utilise indistinctement " ou ' pour encadre une chaîne de caractères, et ne distingue pas les caractères isolés comme Java.</p>
    <h4>Parcourir une chaîne de caractères élément par élément</h4>

    <pre><code class="language-python">for(let i=0; i&ltchaine.length; i++){
  chaine[i];
}</code></pre>

    <h4>Template literal</h4>

    <p>Python permet d'inclure des expressions dans une chaîne de caractères appelées <em>template literal</em>. Pour cela, il faut définir les emplacement avec <strong>{}</strong> et utiliser la méthode <strong>format()</strong>.</p>
    <pre><code class="language-python">{} est le fils de {}.format("Antoine", "Albert")</code></pre>

    <h4>Caster une chaîne de caractères</h4>

    <p>Il est possible de caster une chaîne de caractères lorsque ceux-ci s'apparentent à des nombres. Pour cela, on utilise
      les méthodes int() et float(). Cela s'avère utile lorsqu'on demande à un utilisateur de saisir un nombre. Ce dernier est
      nativement enregistré au format d'une chaîne de caractères qu'il faut caster pour pouvoir appliquer des opérations numériques.</p>

    <pre><code class="language-python">chaine = "12"
nombre = int(chaine)</code></pre>




<!-- ===== LES TABLEAUX ===== -->

<h3 id="py_tableau">Les tableaux</h3>

  <p>Les tableaux (appelés tuples en Python) contiennent des éléments dont le nombre de bouge pas. On peut toutefois changer ces éléments. Un tableau est considéré comme un type élémentaire en Python.</p>

  <p>On peut créer un tableau de la manière suivante :</p>
  <pre><code class="language-python">tab = (element1, element2)</code></pre>

  <p>L'indice du 1er élément d'un tableau est 0. Attention, on ne modifie pas les éléments d'un tuple, qui sont par
  définition immuables.</p>

  <h4>Propriétés d'un tableau</h4>

  <table>
    <tr><th>Propriétés</th><th>Codes</th></tr>
    <tr><td>taille</td><td><pre>len(tab)</pre></td></tr>
    <tr><td>élément d'indice i</td><td><pre>tab[i]</pre></td></tr>
    <tr><td>dernier élément d'une liste</td><td><pre>tab[-1]</pre></td></tr>
    <tr><td>indice d'un élément</td><td><pre>tab.index(element)</pre></td></tr>
  </table>



<!-- ===== LES LISTES ===== -->

<h3 id="py_liste">Les listes</h3>

  <p>Les listes contiennent des éléments dont le nombre peut varier, mais
    l'indice du 1er élément est 0. Les listes sont compatibles avec les
    dictionnaires en ce sens qu'une liste peut contenir des dictionnaires et
  vice versa.</p>

  <p>On peut créer une liste de la manière suivante :</p>
  <pre><code class="language-python">liste = [element1, element2, element3]</code></pre>

  <p>En Python on peut stocker des éléments de différents types dans une liste.</p>
  <pre><code class="language-python">maListe = ["Antoine", 12, false]</code></pre>

  <p>En Python, l'appel à un indice ne figurant pas dans la liste conduit à une exception de la forme <em>IndexError: list index out of range</em>.</p>

  <p>Pour créer une liste vide</p>
  <pre><code class="language-python">maListe = list()</code></pre>

  <h4>Propriétés d'une liste</h4>

  <table>
    <tr><th>Propriétés</th><th>Codes</th></tr>
    <tr><td>taille</td><td><pre>len(maListe)</pre></td></tr>
    <tr><td>élément d'indice i</td><td><pre>maListe[i]</pre></td></tr>
    <tr><td>dernier élément d'une liste</td><td><pre>maListe[-1]</pre></td></tr>
    <tr><td>modifier l'élément d'indice i</td><td><pre>maListe[i] = nouvelleValeur</pre></td></tr>
    <tr><td>indice d'un élément</td><td><pre>maListe.index(element)</pre></td></tr>
    <tr><td>ajout d'un élément à la fin d'une liste</td><td><pre>maListe.append(element)</pre></td></tr>
    <tr><td>ajout d'un élément au début d'une liste'</td><td><pre>maListe.unshift(element)</pre></td></tr>
    <tr><td>ajout d'un élément à l'indice i</td><td><pre>maListe.insert(i, element)</pre></td></tr>
    <tr><td>concaténation de maListe1 et maListe2 enregistrée dans maListe1</td><td><pre>maListe1.extend(maListe2)</pre></td></tr>
    <tr><td>suppression du dernier élément et renvoi de sa valeur</td><td><pre>maListe.pop()</pre></td></tr>
    <tr><td>suppression de l'élément d'indice i</td><td><pre>del maListe[i]</pre></td></tr>
    <tr><td>suppression d'un élément défini par sa valeur, seul le 1er element de cette valeur est supprimé</td><td><pre>maListe.remove(element)</pre></td></tr>
    <tr><td>tri d'une liste d'entiers de façon ascendante (cette fonctionnalité modifie la liste d'origine)</td><td><pre>maListe.sort()</pre></td></tr>
    <tr><td>tri d'une liste d'entiers de façon descendante (cette fonctionnalité modifie la liste d'origine)</td><td><pre>maListe.sort(reverse=True)</pre></td></tr>
    <tr><td>inversion des éléments d'une liste</td><td><pre>maListe.reverse()</pre></td></tr>
  </table>

  <p>Une liste vide a pour taille 0. </p>

  <h4>Parcourir une liste</h4>

  <p>Si on souhaite afficher une liste sans mise en forme particulière, l'utilisation de <strong>print</strong> est suffisante.</p>
  <pre><code class="language-python">print(maListe)</code></pre>

  <p>On peut également afficher les éléments de maListe les uns à la suite des autres.</p>

  <pre><code class="language-python">for i in range(len(maListe)):
    print(maListe[i])</code></pre>

  <p>Python offre la possibilité de parcourir une liste sans référence aux indices, mais en utilisant un itérateur des éléments qui composent la liste. Ceci correspond à l'instruction <strong>forEach</strong> d'autres langages.</p>
  <pre><code class="language-python">for elmt in maListe:
    print(elmt)</code></pre>

  <p>Python offre deux autres possibilités pour afficher les éléments d'une liste :</p>

  <pre><code class="language-python">for value in enumerate(maListe):
    print(value)</code></pre>
  <pre><code class="language-python">for i, value in enumerate(maListe):
    print("indice {}, valeur {}".format(i,value))</code></pre>



  <!-- ====== UTILISATION AVANCEE DES LISTES ===== -->

  <h3 id="py_liste_avance">Utilisation avancée des listes</h3>

  <h4>Affectation par valeurs, affectation par référence</h4>

  <p>Il existe principalement deux manières de copier des listes en Python avec des fonctionnalités différentes. L'affectation
  par référence pointe vers l'adresse d'une liste, et donc tout changement opéré sur la copie affecte l'original. En revanche,
  l'affectation par valeurs copie les éléments d'une liste un à un, et donc tout changement opéré sur la copie n'a aucun effet
  sur l'original. L'affectation par référence consomme moins d'espace mémoire.</p>

  <pre><code class="language-python">maListe = ["a", "b", "c"]
copie_liste = maListe

copie_liste[1] = "hello"
print(maListe)</code></pre>

  <p>Le code ci-dessus qui copie la liste par référence affiche ['a', 'hello', 'c'], alors que le code ci-dessous qui
  copie la liste par valeurs affiche</p>

  <pre><code class="language-python">maListe = ["a", "b", "c"]
copie_liste = list(maListe)

copie_liste[1] = "hello"
print(maListe)</code></pre>

  <p>Ce dernier code est équivalent à :</p>

  <pre><code class="language-python">maListe = ["a", "b", "c"]
copie_liste = list()
for i in range(3):
    copie_liste[i] = maListe[i]

copie_liste[1] = "hello"
print(maListe)</code></pre>

  <h4>Les fonctions callback avec map</h4>

  <pre><code class="language-python">def carre(x):
    return x ** 2

maListe = [1, 2, 3, 4, 5]
print map(carre, maListe) # Affiche [1, 4, 9, 16, 25]</code></pre>

  <h4>Les fonction callback avec filter</h4>

  <pre><code class="language-python">def pair(x):
    return not bool(x % 2)

maListe = [1, 2, 3, 4, 5]
print filter(pair, maListe) # Affiche [2, 4]</code></pre>

  <h4>Les compréhensions de liste</h4>

  <p>Les compréhensions de liste permettent de modifier les éléments d'une liste selon une structure très particulière.
    Elles produisent des résultats semblables à ceux produits par le package Numpy mais dans le cas plus général que celui
    des nombres. Par exemple pour mettre les éléments au carré, on procède ainsi :</p>
  <pre><code class="language-python">nouvelleListe = [elt**2 for elt in maListe]</code></pre>

  <p>Les compréhensions de liste permettent également de filtrer les éléments d'une liste suivant une condition particulière. Par exemple pour rechercher les éléments pairs, on procède ainsi :</p>
  <pre><code class="language-python">nouvelleListe = [elt for elt in maListe if elt%2==0]</code></pre>

<p>Les compréhensions de liste sont préférables aux fonctions map et filter.</p>

  <h4>Conversion d'une liste en chaîne</h4>

  <p>La conversion d'une liste en chaîne et inversement est nécessaire pour effectuer certains traitements sur lse chaînes
    de caractères. En effet, les chaînes sont censées être de taille fixe et il n'existe pas de type Stringbuffer comme em Java par exemple.</p>

  <p>Pour convertir maListe en maChaine avec le séparateur "," :</p>

  <pre><code class="language-python">maListe = ["h", "e", "l", "l", "o"]
maChaine = "-".join(maListe)
print(maChaine # affiche h-e-l-l-o</code></pre>

  <p>Pour convertir maListe en maChaine sans séparateur :</p>

  <pre><code class="language-python">maListe = ["h", "e", "l", "l", "o"]
maChaine = "".join(maListe)
print(maChaine # affiche hello</code></pre>

  <p>Pour convertir maChaine en maListe :</p>

  <pre><code class="language-python">maListe = maChaine.split(", ")</code></pre>

  <p>L'utilisation de join avec des listes de compréhension permet l'affichage de plusieurs lignes dans une même chaìne.</p>

  <pre><code class="language-python">annuaire = [
  (1, "antoine"),
  (5, "celine"),
  (6, "herve")
]

print("\n".join(["%d pour %s" % (nbre, nom) for nbre, nom in annuaire]))</code></pre>

  <p>ce qui affiche : 1 pour antoine <br/>5 pour celine <br/>6 pour herve</p>




<!-- ===== LES DICTIONNAIRES ===== -->

<h3 id="py_dictionnaire">Les dictionnaires</h3>

  <p>Les dictionnaires sont constitués d'un ensemble de clés-valeurs, dans lequel il n'y a aucun ordre.
  Leur structure est similaire à celle d'un format JSON.</p>
  <pre><code class="language-python">dico ={
  "nom" : "Antoine",
  "prenom" : "Hervé"
}</code></pre>

  <p>Pour créer un dictionnaire vide :</p>
  <pre><code class="language-python">dico = dict()</code></pre>

  <p>Pour accéder à un élément du dictionnaire, il ne faut plus appeler son
    indice qui n'existe pas mais appeler la clé de la façon suivante :</p>

  <pre><code class="language-python">dico["nom"]</code></pre>

  <p>Pour ajouter un élément à la fin d'un dictionnaire, il suffit de créer cet élément :</p>
  <pre><code class="language-python">dico["lieuNaissance"] = "Lausanne";</code></pre>

  <h4>Parcourir un dictionnaire</h4>

  <pre><code class="language-python">for cle in dico.keys():
  print(cle)

for valeur in dico.values():
  print(valeur)

for cle, valeur in dico.items():
    print(f"Clé {cle} - Valeur {valeur}")</code></pre>

  <h4>Propriétés d'un dictionnaire</h4>

  <table>
    <tr><th>Propriétés</th><th>Codes</th></tr>
    <tr><td>taille</td><td><pre>len(dico)</pre></td></tr>
    <tr><td>affichage de tous les éléments sans format spécifique</td><td><pre>dico.items()</pre></td></tr>
    <tr><td>modifier l'élément de clé key</td><td><pre>dico["key"] = "value"</pre></td></tr>
    <tr><td>ajout d'un élément</td><td><pre>dico["key"] = "value"</pre></td></tr>
    <tr><td>suppression d'un élément défini par sa clé sans renvoi de sa valeur</td><td><pre>del dico["key"]</pre></td></tr>
    <tr><td>suppression d'un élément défini par sa clé et renvoi de sa valeur</td><td><pre>dico.pop("key")</pre></td></tr>
  </table>

  <h4>Définir les attributs d'un objet à partir d'un dictionnaire</h4>

  <p>Dans le constructeur d'une classe, pour instancier des objets dont les attributs portent le même nom que les clés d'un dictionnaire :</p>

  <pre><code class="language-python">def __init__(self, dico):
  for attr_name, attr_value in dico.items():
    setattr(self, attr_name, attr_value)</code></pre>

<h4>Conversion d'un dictionnaire en chaìne</h4>

  <p>De la même façon qu'avec des listes, on peut transformer un
    dictionnaire en chaìne en spécifiant un séparateur de valeurs
    (attention, seules les clés seront utilisées) :</p>

  <pre><code class="language-python">dico = {'name' : 'daniel', 'age'
    : '30'}
chaine = '#'.join(dico)</code></pre>

  <p>On obtiendra alors comme résultat : name#age</p>

  <h4>Utiliser la méthode setdefault pour afficher la valeur d'une clé</h4>

  <p>La méthode setdefault permet d'éviter de lever une exception dans le
    cas où la clé consultée n'existe pas dans le dictionnaire. Dans ce
    cas la clé est créée et l'élément en 2ème position est la valeur
    attribuée à cette clé. Cette méthode est donc à privilégier
    systématiquement lors de l'appel d'une valeur. Dans l'exemple ci-dessous
    le code affiche Ford lorsqu'on demande la marque et affiche blanche
    lorsqu'on demande la couleur qui n'existait pas auparavant. Notons que le
    dictionnaire a bien été complété d'un élément.</p>

  <pre><code class="language-python">dico = {
  'marque': 'Ford',
  'modele': 'Fiesta'
}

print(dico.setdefaut('marque', 'Citroen')
print(dico.setdefault('couleur', 'blanche')</code></pre>



  <!-- ===== LES FONCTIONS ===== -->

  <h3 id="py_fonction"> Les fonctions </h3>

  <p>La déclaration d'une fonction se réalise de la manière suivante :</p>
  <pre><code class="language-python">def nomFonction(parametre) :
  instructions
  return valeur</code></pre>

  <fieldset><legend>ATTENTION </legend>
    <p>En Python le type de retour de la fonction et le type des arguments ne sont pas spécifiés lors de la déclaration. Il est donc impossible de surcharger une fonction en Python.</p>
  </fieldset>

  <p>L'appel de la fonction se fait de la façon suivante :</p>
  <pre><code class="language-python">int valeur = nomFonction(12)</code></pre>

  <p>Lorsqu'il n'y a pas de valeur de retour, on parle de procédure :</p>
  <pre><code class="language-python">def nomProcedure(parametre) :
    instructions</code></pre>

  <p>L'appel de la procédure se fait de la façon suivante :</p>
  <pre><code class="language-python">nomProcedure(12);</code></pre>

  <p>Pour une fonction comme pour une procédure, on peut définir une valeur de paramètre par défaut si celle-ci n'est pas spécifiée, de la manière suivante :</p>
  <pre><code class="language-python">def nomFonction(parametre1, parametre2=43) :
  instructions
    return valeur</code></pre>

  <p>Bien que la valeur 43 soit attribuée par défaut au parametre2, celui-ci peut prendre n'importe quelle valeur qui lui soit attribuée.</p>

  <p>En Python, pour créer des fonctions attendant un nombre inconnu de paramètres, on utilise la syntaxe</p> <pre>def maFonction(*monTableau)</pre> <p>où <em>monTableau</em> est un tableau de parametres.</p>
    <h4>Documenter une fonction</h4>

    <p>En Python, l'ajout d'une <em>docstring</em> se fait sous le nom de la fonction, avec une indentation et 3 guillements. Elle peut s'étendre sur plusieurs lignes.</p>
    <pre><code class="language-python">def maFonction(parametre) :
  """documentation
  de maFonction"""
  instructions
  return</code></pre>

    <p>On appelle la documentation en utilisant l'instruction <strong>help(maFonction)</strong></p>

    <h4>Fonction anonyme</h4>

    <p>En Python, la fonction anonyme est appelée fonction <em>lambda</em>, mais le principe reste identique. On remplace dans ce cas le mot-clé <strong>def</strong> par <strong>lambda</strong> et on ne spécifie aucun nom pour la fonction créée.</p>
    <pre><code class="language-python">int maVariable = lambda x :
  2*x

   print(maVariable(3))</code></pre>

    <pre><code class="language-python">str maVariable = lambda parametre :
  "Bonjour ",parametre

   print(maVariable("Hervé"))</code></pre>

  <p>On remarque qu'une fonction lambda utilise une construction particuliére et transforme la variable <em>maVariable</em> en fonction.</p>

    <h4>Fonctions prédéfinies </h4>

    <table>
      <tr><th>Fonctions</th><th>Actions</th></tr>
      <tr><td>Math.min(2, 4)</td><td>donne le minimum des paramètres passés en arguments</td></tr>
      <tr><td>Math.random</td><td>génère un nombre aléatoire entre 0 et 1</td></tr>
    </table>

  <h4>Utilisation de la fonction callback en Python</h4>

  <p>Il s'agit d'une fonction qui sert de paramètre à une autre fonction.</p>

  <pre><code class="language-python">def maFonction(x):
  instruction

def autreFonction(maFonction, val):
  return maFonction(val)</code></pre>




  <!-- ===== LES DOCTRINGS ===== -->

  <h3 id="py_doc">Les docstrings</h3>

  <p>Les conventions pour la doctring sont les suivantes :</p>
<pre><code class="language-svg">def ma_fonction(nom):
  """description generale

  Parameters :
  nom (str): description de nom

  Returns :
  nouveau_nom (str): description de nouveau_nom


  description en details"""</code></pre>

  <p>Pour appeler une doctring, il faut taper dans le shell :</p>
<pre><code class="language-svg">help(ma_fonction)</code></pre>



  <!-- ===== LES EXCEPTIONS ===== -->

  <h3 id="py_exception">La gestion des exceptions</h3>

  <p>Elles se construisent suivant les cas de différentes manières :</p>
  <pre><code class="language-python">try: # cas général
  instruction à tester
except:
  instruction en cas d'erreur
finally:
  instruction dans tous les cas

try: # variable non définie
  instruction à tester
except NameError as e:
  instruction en cas d'erreur

try: # le type de la variable est incompatible avec l'instruction
  instruction à tester
except TypeError as e:
  instruction en cas d'erreur

try: # division par 0
  instruction à tester
except ZeroDivisionError:
  instruction en cas d'erreur</code></pre>

  <p>Pour aller plus loin, la documentation Python officielle <a href="https://docs.python.org/3.5/library/index.html"><em>The Python Standard Library</em></a>.</p>



  <!-- ===== LES OBJETS EN PYTHON ===== -->

  <h3 id="py_objet"> La programmation objet</h3>

    <p>La création d'une classe en Python :</p>
    <pre><code class="language-python">class MaClasse:
  MON_ATTRIBUT  # attribut de classe

  __init__(self, nom, prenom):
    self.nom = nom
    self.prenom = prenom

  def uneMethode(parametre):
    instructions

}</code></pre>

  <p>On remarque que la signature d'une méthode ne comprend pas le type renvoyé par la méthode. Notons également que le
  constructeur d'une classe en Python est __init__(self). Le mot-clé self doit obligatoirement apparaître parmi les paramètres
  du constructeur contrairement à d'autres langages. En revanche, il n'est pas nécessaire de définir les attributs, comme nom
    et prenom dans l'exemple ci-dessus, avant la définition des méthodes. Seuls les attributs de classe s'écrivent en majuscule
    avec éventuellement des underscores. Ils n'utilisent pas de mot-clé spécifique. En Python les attributs de classe sont en fait
  vus comme des constantes propres à une classe.</p>

  <p>Les méthodes de classes prennent toujours en paramètre le mot-clé self.</p>

  <p>L'instanciation d'un objet se fait sans recours au mot-clé traditionnel new des autres langages :</p>
  <pre><code class="language-python">monObjet = MaClasse("Charles", "Hervé")</code></pre>

  <p>On peut accéder aux attributs de classe à partir d'un objet mais également directement à partir de la classe de la façon suivante :</p>
  <pre><code class="language-python">MaClasse.MON_ATTRIBUT</code></pre>

  <p>Par défaut toutes les méthodes sont publiques. Pour les rendre protégées il faut ajouter un underscore devant la méthode
  et pour les rendre privées il faut rajouter deux underscores</p>

  <pre><code class="language-python">def _maMethodeProtegee:
def __maMethodePrivee</code></pre>










  <!-- ===== PEP8 ===== -->

  <h3 id="py-pep">Respect du PEP8</h3>

  <p>Python Enhancement Proposal 8 requiert le respect des règles suivantes:</p>
  <ul>
    <li>une ligne doit contenir au maximum 80 caractères</li>
    <li>l'indentation doit contenir 4 espaces</li>
    <li>2 lignes vides au-dessus d'une classe</li>
    <li>les docstrings sont obligatoires pour les méthodes, les classes et les modules</li>
    <li>l'import d'un module ou d'un package doit se faire en début de code</li>
    <li>pas d'espace avant : mais un espace après</li>
    <li>un espace autour d'un opérateur</li>
    <li>un espace autour d'un = pour assigner une valeur à une variable</li>
    <li>pas d'espace autour d'un = pour assigner une valeur par défaut à un paramètre</li>
    <li>une instruction par ligne</li>
    <li>les commentaires sont écrits en anglais</li>
    <li>les modules s'écrivent en minuscule, avec un underscore si besoin</li>
    <li>les packets s'écrivent en minuscule sans underscore</li>
    <li>les classes ont une 1ère lettre en minuscule et peuvent avoir d'autres lettres en majuscule</li>
    <li>les méthodes s'écrivent en minuscule, avec underscore si besoin</li>
    <li>les variables s'écrivent en minuscule, avec underscore si besoin</li>
    <li>les constantes s'écrivent en majuscules, avec underscore si besoin</li>
  </ul>

  <p>PyLint est un logiciel en ligne de commande permettant d'analyser le code en fonction des standards de PEP8.</p>

  <pre>pip install pylint
pylint fichier.py // lance l'analyse de fichier.py</pre>

</section>

<footer>
  Stephane Robin
</footer>

</body>
</html>

<!DOCTYPE HTML>
<html>
<head>
  <title> Memento </title>
  <link rel="stylesheet" href="style.css">
  <meta charset="utf-8">
</head>

<body>

<header>
  <div class="heroImage">
    <div class="heroTexte">
      <h2> C </h2>
    </div>
  </div>
</header>

<div id="bandeau">
  <div id="titre"> <h1> Memento </h1> </div>
  <nav>
    <div class="element"> <a href="index.html">GENERALITES</a> </div>
    <div class="element"> <a href="html.html">HTML</a> </div>
    <div class="element"> <a href="css.html">CSS</a> </div>
    <div class="element"> <a href="javascript.html">JAVASCRIPT</a> </div>
    <div class="element"> <a href="python.html">PYTHON</a> </div>
    <div class="element"> <a href="java.html">JAVA</a> </div>
    <div class="element"> <a href="c.html">C</a> </div>
    <div class="element"> <a href="git.html">GIT</a> </div>
  </nav>
</div>

<section id="principal">

<hr>
    
  <p style="font-weight:bold"> Table des matières :</p>
  <ul>
    <li> <a href="#">Hello world</a> </li>
    <li> <a href="#">Généralités</a> </li>
    <li> <a href="#">Importer un package</a> </li>
    <li> <a href="#">Les variables</a> </li>
    <li> <a href="#">Manipuler des chaînes de caractères</a> </li>
    <li> <a href="#">Saisie par l'utilisateur</a> </li>
    <li> <a href="#">Branchements conditionnels</a> </li>
    <li> <a href="#">Les boucles</a> </li>
    <li> <a href="#">Les fonctions</a> </li>
    <li> <a href="#">Les pointeurs</a> </li>
    <li> <a href="#">Le package math.h</a> </li>
  </ul>
  
  <hr>

  <!-- ===== HELLO WORLD ===== -->

  <h3>Hello world</h3>

  <p>Commençons par le traditionnel "Hello world".</p>
  <pre>#include &ltstdio.h&gt
#include &ltstdlib.h&gt

int main(int argc, char* argv[]){
  printf("Hello world");
  return 0;
}</pre>

  <hr>

  <!-- ===== GENERALITES ===== -->

  <h3> Généralités </h3>

    <p>Les fichiers C ont pour extension <em>.c</em></p>
    
    <p>Toutes les instructions se terminent par <strong>;</strong></p>

    <p>En C, chaque fonction renvoie une fois terminé une valeur. En pratique 0 signifie que tout s'est bien passé.</p>

    <p> <strong>\n</strong> s'emploie pour un retour à la ligne.</p>
    <p> <strong>\t</strong> s'emploie pour une tabulation.</p>

    <p>Les commentaires sur une ligne s'expriment grâce aux symboles <strong>//</strong>. En revanche les commentaires sur plusieurs lignes figurent entre les symboles <strong>/*</strong> et <strong>*/</strong>.</p>

<hr>
    
<!--- ===== IMPORTER UN PACKAGE ===== -->
    
<h3>Importer un package</h3>
    
    <p>L'installation de librairies se fait à l'aide de l'instruction <strong>#include &ltnomLibrairie&gt</strong>.</p>

<hr>
    
<!--- ===== LES VARIABLES ===== -->
    
<h3>Les variables</h3>
  
<p>C n'est pas un langage dynamique. Il est nécessaire que définir le type de variables avant leur utilisation. Les différents types de variables en C sont les suivants :</p> 
    
  <table>
    <tr><th>Types</th><th>Mots-clés</th></tr>
    <tr><td>entier court</td><td>signed char</td></tr>
    <tr><td>entier</td><td>int</td></tr>
    <tr><td>entier long</td><td>long</td></tr>
    <tr><td>nombre décimal</td><td>float</td></tr>
    <tr><td>nombre décimal long</td><td>double</td></tr>
    <tr><td>entier court positif</td><td>unsigned char</td></tr>
    <tr><td>entier positif</td><td>unsigned int</td></tr>
    <tr><td>entier long positif</td><td>unsigned long</td></tr>
  </table>

<p>Attention, les <strong>signed char</strong> et <strong>unsigned char</strong>, ... sont en fait des nombres malgré leur dénomination trompeuse. Tous ces différents types de nombres ont été créés pour économiser de la mémoire lors de leur déclaration.</p>

<p>Au moment de la déclaration d'une variable, C réserve un emplacement en mémoire, mais la valeur attribuée initialement à la variable correspond à la dernière valeur prise par cet emplacement de mémoire. Il est donc important de déclarer et d'initialiser en même temps pour éviter des erreurs, en attribuant par exemple la valeur 0 à la variable.</p>

<h4>Particularités de C</h4>

<p>En C il n'existe pas de type booleen. On fait donc prendre les valeurs 0 et 1 à une variable qui va jouer le rôle d'un booléen. Il n'existe pas non plus de type chaîne de caractères. En revanche, le type char qui est un type particulier de nombres compris entre -128 et 127, permet en fait de représenter des caractères. La correspondance entre les nombres et les caractères est assurée par la table ASCII.</p>


<h4>Affichage d'une variable</h4>
    
<pre>printf("Antoine a %d ans et %d voitures", age, nbreVoitures);</pre>
<p></p>

<table>
    <tr><th>Types</th><th>Mots-clés</th></tr>
    <tr><td>int</td><td>%d</td></tr>
    <tr><td>long</td><td>%ld</td></tr>
    <tr><td>float</td><td>%f</td></tr>
    <tr><td>pointeur</td><td>%p</td></tr>
    <tr><td>char</td><td>%d pour afficher le nombre, %c pour afficher le caractère</td></tr>
    <tr><td>chaîne de caractères</td><td>%s</td></tr>
</table>

<h4> Les principales opérations </h4>

  <table>
    <tr><th>Opérations</th><th>Symboles</th></tr>
    <tr><td>addition</td><td>+</td></tr>
    <tr><td>soustraction</td><td>-</td></tr>
    <tr><td>multiplication</td><td>*</td></tr>
    <tr><td>division pour des nombres décimaux</td><td>/</td></tr>
    <tr><td>partie entière d'une division</td><td>/</td></tr>
    <tr><td>modulo</td><td>%</td></tr>
    <tr><td>concaténation</td><td>+</td></tr>
    <tr><td>affectation</td><td>=</td></tr>
    <tr><td>égalité</td><td>==</td></tr>
    <tr><td>incrémentation</td><td>++</td></tr>
    <tr><td>décrémentation</td><td>--</td></tr>
    <tr><td>ET logique</td><td>&&</td></tr>
    <tr><td>OU logique</td><td||</td></tr>
    <tr><td>NON logique</td><td>!</td></tr>
  </table>

<h4>Les opérateurs de comparaison</h4>

  <table>
    <tr><th>Signification</th><th>Opérateurs</th></tr>
    <tr><td>égalité</td><td>==</td></tr>
    <tr><td>égalité (valeur et type)</td><td>===</td></tr>
    <tr><td>différent</td><td>!=</td></tr>
    <tr><td>inférieur</td><td><</td></tr>
    <tr><td>inférieur ou égal</td><td><=</td></tr>
    <tr><td>supérieur</td><td>></td></tr>
    <tr><td>supérieur ou égal</td><td>>=</td></tr>
  </table>

<h4>Particularité de C</h4>

<p>En C, le signe division <strong>/</strong> n'a pas le même sens selon que les termes de calcul sont des entiers ou des décimaux.</p> 
<table>
    <tr><th>Type</th><th>Calcul</th><th>Résultat</th></tr>
    <tr><td><pre>int a = 5;
int b = 2;</pre></td><td><pre>int resultat = a/b</pre></td><td>2</td></tr>
    <tr><td><pre>int a = 5;
int b = 2;</pre></td><td><pre>float resultat = a/b</pre></td><td>2.0</td></tr>
    <tr><td><pre>float a = 5.0;
float b = 2.0;</pre></td><td><pre>float resultat = a/b</pre></td><td>2.5</td></tr>
</table>

<h4>Les constantes</h4>

<p>On déclare une constante en C avec l'instruction :</p>
<pre>const int MON_NOMBRE = 5;</pre>

<hr>

<!-- ===== MANIPULER DES CHAINES DE CARACTERES ===== -->

<h3>Manipuler des chaînes de caractères</h3>

<p>La bibliothèque <em>string.h</em> offre une multitude de fonctions dédiées aux chaînes.</p>
<pre>#include &ltstring.h&gt</pre>

<p>En C un caractère est en fait un nombre stocké tel quel dans la mémoire et affiché sous forme de caractère si on le spécifie avec l'attribut <em>%c</em>, en utilisant la table ASCII.</p>

<pre>char lettre = 'a';
printf("%d", lettre);</pre>

<p>affiche 97. En revanche, le code :</p>

<pre>char lettre = 'a';
printf("%c", lettre);</pre>

<p>affiche bien la lettre <em>a</em>. Notons que les caractères sont entourés de <strong>'</strong> et non de <strong>"</strong>.</p>
<p>En C une chaîne de caractères est un tableau de caractères et le dernier élément de cette chaîne est obligatoirement <em>\0</em></p>
<p>Par conséquent pour stocker une chaîne de 7 caractères, il faut en fait un tableau de 8 éléments.</p>

<p>Dans la pratique, pour initialiser et afficher une chaîne de caractères, on utilisera :</p>
<pre>char chaine[] = "bonjour";
printf("%s", chaine);</pre>

<p>On constate donc qu'il n'est pas nécessaire de définir la taille du tableau représentant la chaine, et qu'il n'est pas nécessaire de passer par une boucle pour afficher la chaine. Par ailleurs, il s'affiche bien des lettres et non des chiffres comme on aurait pu le craindre. En fait en utilisant des guillemets, le compilateur calcule automatiquement la taille nécessaire, il compte les lettres et ajoute 1 case mémoire pour placer \0</p>

<p>Attention, cette méthode de déclaration-initialisation automatique d'une chaîne de caractères ne fonctionne qu'au moment de l'initialisation. Après il est impossible d'écrire :</p>
<pre>chaine = "bonjour"</pre>
<p>Il faudra ensuite utiliser une boucle pour définir la chaine.</p>

<p>Notons qu'une chaîne de caractères n'est par définition pas modifiable. Toutefois, il est quand même possible d'en modifier les termes uns à uns.</p>

<table>
    <tr><th>Propriétés</th><th>Codes</th></tr>
    <tr><td>taille sans compter le \0</td><td><pre>strlen(chaine)</pre></td></tr>
    <tr><td>copie d'une chaîne à l'intérieur d'une autre</td><td><pre>strcpy(chaineAcopier, chaineDestinataire)</pre></td></tr>
    <tr><td>concaténer chaine1 dans chaine2</td><td><pre>strcat(chaine1, chaine2)</pre></td></tr>
    <tr><td>comparer deux chaînes</td><td><pre>strcmp(chaine1, chaine2)</pre></td></tr>
    <tr><td>rechercher le caractère a dans chaine</td><td><pre>strchr(chaine, 'a')</pre></td></tr>
</table>

<p>Attention, de façon contre-intuitive, la comparaison de deux chaines renvoie 0 si les chaînes sont identiques et un nombre positif ou négatif sinon.</p>

<hr>

<!-- ===== SAISIE PAR L'UTILISATEUR ===== -->

<h3>Saisie par l'utilisateur</h3>

<p>Dans le cas d'une valeur numérique :</p>
<pre>int age = 0;
printf("Quel âge avez-vous ?");
scanf("%d", &age);
printf("Vous avez %d ans, age);</pre>

<p>Dans le cas d'une chaine de caractères :</p>
<pre>char nom[100];
printf("quel est votre nom?");
scanf("%s", nom);</pre>

<h4>Particularité de C</h4>

<p>Si le nombre saisi par l'utilisateur ne correspond pas au type, C ne lève pas une exception mais conserve la valeur initialisée de la variable. Si le type attendu est <strong>int</strong> mais que le type saisi est en fait <strong>float</strong>, C ne va toujours pas lever une exception mais tronquer le nombre saisi pour le transformer en entier.</p>

<hr>

<!-- ===== BRANCHEMENT CONDITIONNEL ===== -->

<h3>Branchement conditionnel</h3>

    <h4>La condition if</h4>

    <pre>if (condition){
  instructions;
}
else{
  instructions;
}</pre>

    <p>Il est possible d'enchaîner les <strong>else</strong>.</p>

    <pre>if (condition){
  instructions;
}
else if{
  instructions;
}
else{
  instructions;
}</pre>

    <h4>L'instruction switch</h4>

    <pre>switch(maVariable){
  case valeur1:
    instruction;
    break;
  case valeur2:
    instruction;
    break;
  case valeur3:
    instruction;
    break;
  default:
    instruction;
}</pre>

<hr>

<!-- ===== LES BOUCLES ===== -->

<h3> Les boucles </h3>

   <h4>La boucle while</h4>

    <pre>while (condition){
  instructions;
 }</pre>

    <h4>La boucle for</h4>

    <pre>for (int i=0; i<5; i++){
  instructions;
}</pre>

    <pre>for elmt in chaine :
  instructions</pre>

    <h4>Particularité de Python</h4>

    <pre>for lettre in chaine :
  if lettre in "aeiouy" :
    instructions</pre>

      <p>Le mot clé <strong>break</strong> permet d'interrompre une boucle et d'exécuter le code qui suit la boucle. Le mot clé <strong>continue</strong> permet de continuer une boucle en repartant du début du bloc sans exécuter ce qui suit <strong>continue</strong> dans le bloc.</p>

<hr>

<!-- ===== LES FONCTIONS ===== -->

<h3>Les fonctions</h3>

<pre>type maFonction(type parametre){
    instructions;
    return resultat
}</pre>

<p>Pour les fonctions qui ne renvoient pas de valeur (appelées procédures), on remplace le type par <strong>void</strong> et on renvoie <strong>return 0</strong>.</p>

<h4>Particularité de C</h4>

<p>Afin de pouvoir lire des fonctions se trouvant après la méthode main(), il faut rajouter en début de code derrière les préconditions le prototype des fonctions utilisées :</p>
<pre>#include &ltstdio.h&gt
#include &ltstlib.h&gt
type maFonction(type parametre);</pre>
<p>En fait, il existe deux types de fichiers, les <em>.c</em> qui sont les codes sources et les <em>.h</em> appelés headers qui contiennent les prototypes des fonctions. Il faut importer ces fichiers <em>.h</em> en tant que préconditions dans les fichiers <em>.c</em> pour éviter d'avoir à rajouter tous les prototypes en début de code.</p>
<pre>#include &ltstdio.h&gt
#include &ltstlib.h&gt
#include "monFichier.h"  # en reference a monFichier.c</pre>
<p>Notons que les fichiers sont importés sans chevron mais avec des guillemets alors que les packages sont importés avec chevrons.</p>

<p>Attention, cette règle d'emploi des prototypes est importante. Lorsqu'on appelle une fonction située dans monFichier.c depuis le fichier main.c il est nécessaire d'inclure le prototype de cette fonction dans les préconditions pour que le compilateur puisse vérifier que l'appel de la fonction est conforme à sa declaration. Il est donc nécessaire d'importer monFichier.h pour utiliser une fonction de monFichier.c</p>

<hr>

<!-- ===== LES TABLEAUX ===== -->

<h3>Les tableaux</h3>

<p>Les tableaux en C sont des objets contenant des variables de même type, et disposant d'une taille fixée.</p>
<p>Notons que les adresses des variables d'un tableau sont contigues.</p>
<p>Pour définir un tableau de 5 <em>int</em> :</p>
<pre>int tableau[5];</pre>

<p>Pour initialiser un tableau lorsqu'on connaît les valeurs à l'avance :</p>
<pre>int tableau[5] = {0, 4, 3, 5, 2};</pre>

<p>Comme dans tous les langages, le premier indice d'un tableau est 0.</p>
<p>Par ailleurs, le code suivant renvoie l'adresse de la première case du tableau :</p>
<pre>int tab[5];
print("%d", tab);</pre>

<p>Pour parcourir un tableau :</p>
<pre>for(int i=0; i<5; i++){
    printf("%d \n", tableau[i];
}</pre>

<h4>Propriétés d'un tableau</h4>

  <table>
    <tr><th>Propriétés</th><th>Codes</th></tr>
    <tr><td>taille</td><td><pre>len(tab)</pre></td></tr>
    <tr><td>élément d'indice i</td><td><pre>tab[i]</pre></td></tr>
    <tr><td>dernier élément d'une liste</td><td><pre>tab[-1]</pre></td></tr>
    <tr><td>modifier l'élément d'indice i</td><td><pre>tab[i] = nouvelleValeur</pre></td></tr>
    <tr><td>indice d'un élément</td><td><pre>tab.index(element)</pre></td></tr>
  </table>

<h4>Une initialisation particulière à C</h4>

<pre>int tableau[5] = {1};</pre>
<p>Cette instruction va en fait affecter la valeur 1 au 1er élément du tableau, puis la valeur 0 aux quatre autres.</p>

<hr>
<!-- ===== LES POINTEURS ===== -->

<h3>Les pointeurs</h3>

<p>Un pointeur est une variable particulière contenant l'adresse d'une autre variable. Pour créer un pointeur, on rajoute le symbole * au type de variable :</p>
<pre>int* maVariable;</pre>

<p>Considérons la variable <em>nbre</em> à laquelle on affecte la valeur 12. L'adresse de la variable <em>nbre</em> est notée <em>&nbre</em> et donnée par le pointeur <em>pointeurSur_nbre</em>. L'instruction <em>*pointeurSur_nbre</em> permet d'accéder à la valeur de <em>nbre</em> à partir de son pointeur.</p>

<img src="pointeur.png">

<p>Le code suivant :</p>
<pre>int nbre = 12;
int* pointeur = &nbre;
printf("%d \n", nbre);
printf("%p \n", &nbre);
printf("%p \n", pointeur);
printf("%d", *pointeur);</pre>

<p>affiche le résultat :</p>
<p>12 <br> 0x7ffedfc1da8c <br> 0x7ffedfc1da8c <br> 12</p>

<p>L'adresse d'une variable est écrite en hexadécimal. Il est par ailleurs important d'initialiser un pointeur avec la valeur NULL.</p>

<h4>Intérêt des pointeurs</h4>

<p>Le code suivant renvoie la valeur 0 car la valeur modifiée de maVariable reste dans la fonction modification(). En effet maVariable n'a pas une portée globale, ce qui serait à proscrire. On pourrait contourner ce problème en définissant une variable prenant la valeur de maVariable dans le main.</p>
<pre>void modification(int parametre);

int main(int argc, char* argv[]) {
    
    int maVariable = 0;
    modification(maVariable);
    printf("%d", maVariable);
    
    return (EXIT_SUCCESS);
}

void modification(int parametre){
    parametre = parametre+2;
}</pre>

<p>Si on modifie ce code en utilisant un pointeur, on peut changer la valeur de maVariable bien qu'elle ne soit pas globale. On obtient dans ce cas 2 :</p>
<pre>void modification(int* pointeurParametre);

int main(int argc, char* argv[]) {
    
    int maVariable = 0;
    modification(&maVariable);
    printf("%d", maVariable);
    
    return (EXIT_SUCCESS);
}

void modification(int* pointeurParametre){
    *pointeurParametre = *pointeurParametre+2;
}</pre>

<hr>

<!-- ===== LE PACKAGE MATH ===== -->

<h3>Le package math.h</h3>

<pre>#include &ltmath.h&gt</pre>
<p></p>

<table>
    <tr><th>Instruction</th><th>Effet obtenu</th></tr>
    <tr><td>floor(x)</td><td>plus grand entier inférieur ou égal à x, renvoie un double</td></tr>
    <tr><td>ceil(x)</td><td>plus petit entier supérieur ou égal à x, renvoie un double</td></tr>
    <tr><td>fabs(x)</td><td>valeur absolue de x, renvoie un double</td></tr>
    <tr><td>exp(x)</td><td>exponentielle de x, renvoie un double</td></tr>
    <tr><td>log(x)</td><td>logarithme en base e de x, renvoie un double</td></tr>
    <tr><td>pow(x, y)</td><td>x puissance y</td></tr>
    <tr><td>sqrt(x)</td><td>racine carrée de x, renvoie un double</td></tr>
    <tr><td>pi</td><td>pi = 3,14</td></tr>
    <tr><td>cos(x)</td><td>cosinus de x pour x en radians, renvoie un double</td></tr>
    <tr><td>sin(x)</td><td>sinus de x pour x en radians, renvoie un double</td></tr>
    <tr><td>tan(x)</td><td>tangente de x pour x en radians, renvoie un double</td></tr>
    <tr><td>acos(x)</td><td>arc cosinus de x en radians, renvoie un double</td></tr>
    <tr><td>asin(x)</td><td>arc sinus de x en radians, renvoie un double</td></tr>
    <tr><td>atan(x)</td><td>arc tangente de x en radians, renvoie un double</td></tr>
  </table>

</section>

<footer>
</footer>

</body>
</html>

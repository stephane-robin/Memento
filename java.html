<!DOCTYPE HTML>
<html>
<head>
  <title> Memento </title>
  <link rel="stylesheet" href="style.css">
  <meta charset="utf-8">
</head>

<body>

<header>
  <div class="heroImage">
    <div class="heroTexte">
      <h2> Java </h2>
    </div>
  </div>
</header>

<div id="bandeau">
  <div id="titre"> <h1> Memento </h1> </div>
  <nav>
    <div class="element"> <a href="index.html">HTML</a> </div>
    <div class="element"> <a href="css.html">CSS</a> </div>
    <div class="element"> <a href="javascript.html">JAVASCRIPT</a> </div>
    <div class="element"> <a href="python.html">PYTHON</a> </div>
    <div class="element"> <a href="java.html">JAVA</a> </div>
    <div class="element"> <a href="c.html">C</a> </div>
    <div class="element"> <a href="git.html">GIT</a> </div>
  </nav>
</div>

<section id="principal">

    <div class="bloc">

        <div class="gauche">
            <p>Java est un langage orienté objet qui utilise un compilateur (javac) puis une machine virtuelle
                compatible toutes plateformes JVM Java Virtual Machine pour interpréter le Byte code. De ce fait,
                c'est un langage offrant une grande portabilité.
                C’est un langage à la fois compilé et interprété. Il est donc plus rapide que Python (interprété) mais
                plus lent que C++ (compilé). java -version en ligne de commande permet de vérifier que java est installé.</p>
        </div>

        <div class="droite">
            <img src="java.png" width="60" height="100">
        </div>

    </div>

    <hr>

    <p style="font-weight:bold"> Table des matières :</p>
        <ul>
            <li> <a href="">La programmation réseau</a> </li>
            <li> <a href="#">Les sockets</a> </li>
            <li> <a href="#">Les streams</a> </li>
            <li> <a href="#">Les proxys</a> </li>
            <li> <a href="#">Le RMI</a></li>
            <li> <a href="#">JMS</a></li>
            <li> <a href="#">Les services Web</a></li>
        </ul>

    <hr>

    <!-- EXECUTER JAVA AU TERMINAL -->

    <h3>Exécuter Java au terminal</h3>

    <p>Pour exécuter un programme Java en utilisant le terminal, il faut d'abord se rendre dans le dossier comportant le fichier, puis compiler le programme avec la commande <strong>javac monFichier.java</strong>. Le fichier se transforme alors en binaire exécutable par la Machine Virtuelle Java : monFichier.class. Pour exécuter ce programme il reste maintenant à utiliser la commande <strong>java monFichier</strong>.</p>

    <hr>

<!-- ===== LA PROGRAMMATION RESEAU ===== -->

<h3>La programmation réseau</h3>

<h4>Rappels sur les réseaux</h4>

<p>La communication réseau est initialement définie par le modèle OSI en 7 couches. Toutefois, la plupart des logiciels reposent sur le modèle TCP/IP en 4 couches : réseau, Internet, transport, application. C'est dans cette dernière couche du modèle TCP/IP que se positionne Java.</p>
<p>Notons que par défaut les principaux protocoles de transfert utilisent les ports suivants :</p>
<ul>
    <li>http : port 80</li>
    <li>ftp : port 20 ou 21</li>
    <li>smtp : port 25</li>
</ul>

<h4>La classe InetAddress</h4>

<p>Pour manipuler des adresses IP, on utilise la classe InetAddress.</p>
<pre>import java.net.*;

try{
    InetAddress adresse = InetAddress.getByName("meteocentrale.ch");
}catch (UnknownHostException e) {
    e.printStackTrace();
}</pre>
<p>A noter que dans le cas de l'adresse locale, on peut définir indifféremment :</p>
    <pre>import java.net.*;

try{
    InetAddress adresse = InetAddress.getByName("localhost");
    InetAddress adresse = InetAddress.getLocalHost();
}catch (UnknownHostException e) {
    e.printStackTrace();
}</pre>

    <p>Les méthodes associées à la classe InetAddress nécessitent également la gestion de UnknownHostException :</p>
<table>
    <tr><th>Objectif</th><th>Code</th></tr>
    <tr><td>nom de l'hôte (client)</td><td>adresse.getHostName()</td></tr>
    <tr><td>adresse IP</td><td>adresse.getHostAddress()</td></tr>
    <tr><td>teste si l'adresse est de type boucle locale</td><td>adresse.isLoopbackAddress()</td></tr>
</table>

    <p>Certains sites Internet peuvent avoir plusieurs adresses IP :</p>
<pre>import java.net.*;

try{
    InetAddress[] adresses = InetAddress.getAllByName("amazon.fr");
    System.out.println("Toutes les adresses IP : ");
    for(InetAddress valeur : adresses)
        System.out.println(" - " + valeur.getHostAddress());
}catch(UnknownHostException e) {
        e.printStackTrace();
}</pre>

<h4>La classe URL</h4>

<p>On peut également utiliser la classe URL pour récupérer les données d'un site Internet :</p>
<pre>import java.io.*;
import java.net.*;

try {
    URL url = new URL("http://www.meteofrance.fr");

    }catch(MalformedURLException e) {
        e.printStackTrace();
}
</pre>

    <p>Les méthodes associées à la classe URL nécessitent également la gestion de MalformedURLException.</p>

<table>
    <tr><th>Objectif</th><th>Code</th></tr>
    <tr><td>nom du site</td><td>url.getAuthority()</td></tr>
    <tr><td>port par défaut</td><td>url.getDefaultPort()</td></tr>
    <tr><td>nom de l'hébergeur</td><td>url.getHost()</td></tr>
    <tr><td>numéro de port spécifié</td><td>url.getPort()</td></tr>
    <tr><td>protocole</td><td>url.getProtocol()</td></tr>
</table>

<p>Lorsque url.getPort() renvoie -1, cela signifie que le port n'a pas été spécifié dans l'URL.</p>

<p>Pour vérifier qu'une saisie utilisateur correspond à une url, on peut par exemple utiliser la condition :</p>
<pre>if(host.matches("[a-zA-Z\\.]+"))</pre>

<hr>

<!-- ===== LES SOCKETS ===== -->

<h3>Les sockets</h3>

    <p>Les sockets sont des API permettant de gérer les communications entre programmes. La communication de plusieurs machines sur un réseau nécessite donc la connaissance d'adresses, de ports, de protocoles et l'utilisation de sockets. Les sockets permettent de se connecter à une machine distante, de recevoir et envoyer des données, de fermer une connexion établie, d'attendre une connexion de l'extérieur, d'écouter les communications entrantes.</p>
<p>Une même socket sert aussi bien à envoyer qu'à recevoir des communications.</p>

    <p>Une socket est identifiée de manière unique par l'adresse IP de la machine suivi du numéro de port utilisé, ce dernier étant compris entre 1024 et 65536.</p>

    <p>Java fait la différence entre deux types de sockets : côté client et côté serveur.</p>

    <p>Une socket côté client permet de se connecter à une machine distante afin de communiquer avec elle. L'utilisation de socket côté client se déroule ainsi :</p>
    <ul>
        <li>connexion avec le serveur</li>
        <li>ouverture de la communication avec le serveur</li>
        <li>envoi des messages</li>
        <li>fermeture de la connexion</li>
    </ul>

    <p>Un serveur utilise une socket spécifique pour recevoir des demandes de connexion, puis crée une socket de communication pour échanger avec le client. L'utilisation de socket côté serveur se déroule ainsi :</p>
    <ul>
        <li>attente de demande de connexion venant d'un client</li>
        <li>ouverture de la communication avec le client</li>
        <li>traitement des messages</li>
        <li>fermeture de la connexion</li>
    </ul>

    <p>Les sockets travaillent en full-duplex, i.e. le client et le serveur peuvent envoyer et recevoir des signaux simultanément. Il n'y a donc aucune attente.</p>

    <h4>Le mode connecté</h4>

    <p>En mode connecté, deux sockets établissent une communication durable qui permet d'éviter de transmettre l'identité de la socket destinatrice à chaque envoi. Dans ce cas, un des programmes prend le rôle du serveur et l'autre le rôle du client. Le serveur est donc vu comme un programme rendant des services aux clients. La socket côté serveur doit être définie avant la socket côté client.</p>
    <p>En mode connecté, le serveur doit être lancé en premier.</p>

    <p>La création d'une socket côté serveur utilise la classe ServerSocket et se fait grâce à l'une des instructions :</p>
    <pre>import java.net.*;
import java.io.*;

try{
    // crée une socket serveur en fixant le nmr de port
    ServerSocket socket_serveur = new ServerSocket(int port);

    // crée une socket serveur en fixant le nmr de port et taille de file d'attente de
    // demande de connexion
    ServerSocket socket_serveur = new ServerSocket(int port, int backlog);

    // crée une socket serveur en fixant le nmr de port, taille de file d'attente de
    // demande de connexion et adresse IP
    ServerSocket socket_serveur = new ServerSocket(int port, int backlog, InetAddress
        adresse);
}catch((IOException e){
    e.printStackTrace();
}</pre>

    <p>Le serveur attend ensuite les demandes de connexion en utilisant la fonction bloquante accept() i.e. qu'elle ne libère pas le programme tant qu'elle n'a pas reçu de demande de connexion :</p>

    <p>La création d'une socket côté client utilise la classe Socket et se fait grâce à l'une des instructions :</p>
    <pre>import java.net.*;
import java.io.*;

try{
    // crée une socket client connectée avec le serveur dont le nom et le nmr de port
    // sont donnés
    Socket socket_client = new Socket(String host, int port);

    // crée une socket client connectée avec le serveur dont l'adresse IP et le nmr de
    // port sont donnés
    Socket socket_client = new Socket(InetAddress adresse, int port);

    // crée une socket client connectée avec le serveur dont le nom et le nmr de port
    // sont donnés, fixe l'adresse IP locale et le nmr de port local
    Socket socket_client = new Socket(String host, int port, InetAddress adresseLocale,
        int localPort);

    // crée une socket client connectée avec le serveur dont l'adresse IP et le nmr de port
    // sont donnés, fixe l'adresse IP locale et le nmr de port local
    Socket socket_client = new Socket(InetAddress adresse, int port, InetAddress
        adresseLocale, int localPort);
}catch(IOException e){
    e.printStackTrace();
}</pre>

    <p>La machine virtuelle Java ferme les sockets non utilisés à la fin de l'exécution du programme. Toutefois, le nombre de sockets ouvertes par un programme est limité, ce qui conduit à des erreurs quand cette limite est atteinte. La méthode close() permet de fermer la connexion.</p>

    <p>Les méthodes de la classe Socket permettant d'obtenir des informations sur la connexion et nécessitent également la gestion de IOException :</p>

    <table>
        <tr><th>Instruction</th><th>Résultat</th></tr>
        <tr><td>socket_client.getInetAddress()</td><td>fournit l'adresse IP distante</td></tr>
        <tr><td>socket_client.getLocalAddress()</td><td>fournit l'adresse IP locale</td></tr>
        <tr><td>socket_client.getPort()</td><td>fournit le nmr de port distant</td></tr>
        <tr><td>socket_client.getLocalPort()</td><td>fournit le nmr de port local</td></tr>
    </table>

<p><em>Exemple complet en mode connecté :</em></p>

    <pre>import java.io.*;   // pour OutputStream et write()
import java.net.*;  // pour ServerSocket, getOutputStream(), accept() et close()

public class ServeurConnect {

    public ServeurConnect(){
        try{
            // creation socket serveur
            ServerSocket socket_serveur = new ServerSocket(5555);
            // attente demande de connexion venant du client puis creation d'une
            // connexion
            Socket connexion = socket_serveur.accept();
            // ouverture communication avec le client
            OutputStream com_sortante = connexion.getOutputStream();

            // traitements
            byte[] tableau_data = {1,2,3,4,5};
            com_sortante.write(tableau_data);

             // fermeture connexion
            connexion.close();
        }catch(IOException e){
            e.printStackTrace();
        }
    }
}

import java.io.*;   // pour InputStream et read()
import java.net.*;  // pour Socket, getInputStream() et close()

public class ClientConnect {

    public ClientConnect(){
        try{
            // creation socket client connectée au serveur sur le port 5555
            Socket socket_client = new Socket("localhost", 5555);
            // ouverture communication avec le serveur
            InputStream com_entrante = socket_client.getInputStream();

            // traitement
            byte[] tableau_buffer = new byte[5];
            int recu = com_entrante.read(tableau_buffer);

            // fermeture connexion
            socket_client.close();
        }catch(IOException e){
            e.printStackTrace();
        }
    }
}</pre>

    <h4>Le mode non connecté</h4>

    <p>En mode non connecté, le destinataire de la socket est précisé à chaque envoi. La communication utilise dans ce cas la classe DatagramSocket.</p>

    <p>En mode non connecté, le programme récepteur doit être lancé en premier.</p>
    <h4>Tester les ports disponibles du client</h4>

    <p>Pour tester les 1024 premiers ports du client à l'aide de cette classe :</p>
    <pre>for(int i = 1; i <= 1024; i++){
    try {
        Socket soc = new Socket("127.0.0.1", i);
        System.out.println("ports autorisés sur la machine : " + i);
    } catch (UnknownHostException e) {
        e.printStackTrace();
    }catch (IOException e) {
        System.out.println("ioexception");
        // le port n'est pas ouvert ou n'est pas autorisé
    }
}</pre>

<p>Pour spécifier sur quel port du client le serveur devra répondre :</p>
    <pre>try {
    //Nous spécifions que la réponse devra se faire par ce chemin
    InetAddress lo = InetAddress.getByName("188.165.53.185");

    //Le fait de mettre 0 dans le numéro de port de réponse
    //informe que n'importe quel numéro est accepté
    Socket soc = new Socket("www.adret-attitude.ch", 80, lo, 0);
}catch (UnknownHostException e) {
    e.printStackTrace();
} catch (Exception e) {
    e.printStackTrace();
}</pre>

    <h4>Communiquer avec un serveur</h4>

    <p>On utilise l'objet HttpURLConnection.</p>
    <p>Les flux BufferedInputStrean et BufferedOutputStrean permettent de gagner en performance plutôt que de travailler directement avec les sockets.</p>

    <hr>

    <!-- LES STREAMS -->

    <h3>Les streams</h3>



<hr>

    <!-- ===== LES PROXYS ===== -->

    <h3>Les proxys</h3>

    <p>Un proxy constitue une autre façon de se connecter à un serveur. Le proxy est un intermédiaire faisant le lien entre le client et le serveur.</p>
<pre>import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.Proxy;
import java.net.Socket;
import java.net.SocketAddress;

//On crée une adresse correspondant à notre proxy
SocketAddress proxyAddress = new InetSocketAddress("10.10.10.10", 8080);

//On instancie la classe Proxy avec le type souhaité
Proxy proxy = new Proxy(Proxy.Type.SOCKS, proxyAddress);

//On crée notre socket utilisant le proxy
Socket s = new Socket(proxy);

//On crée l'adresse que l'on souhaite atteindre via le proxy
SocketAddress remote = new InetSocketAddress("www.adret-attitude.ch", 80);
try {
    //On connecte le tout !
    s.connect(remote);
} catch (IOException e) {
    e.printStackTrace();
}</pre>

    <p></p>

    <table>
        <tr><th>Objectif</th><th>Code</th></tr>
        <tr><td>port côté serveur</td><td>s.getPort()</td></tr>
        <tr><td>port côté client</td><td>s.getLocalPort()</td></tr>
        <tr><td>nom hôte distant</td><td>s.getInetAddress().getHostName()</td></tr>
        <tr><td>adresse hôte distant</td><td>s.getInetAddress().getHostAddress()</td></tr>
        <tr><td>adresse socket hôte distant</td><td>s.getRemoteSocketAddress()</td></tr>
    </table>

    <pre>try {
    Socket s = new Socket("www.adret-attitude.ch", 80);
    System.out.println("Port de communication côté serveur : " + s.getPort());
    System.out.println("Port de communication côté client : " + s.getLocalPort());
    System.out.println("Nom de l'hôte distant : " + s.getInetAddress().getHostName());
    System.out.println("Adresse de l'hôte distant : " + s.getInetAddress().getHostAddress());
    System.out.println("Adresse socket de l'hôte distant : " + s.getRemoteSocketAddress());
} catch (UnknownHostException e) {
        e.printStackTrace();
} catch (IOException e) {
        e.printStackTrace();
}</pre>

    <hr>

    <!-- Le RMI -->

    <h3>Le mécanisme RMI</h3>

    <p>Le RMI permet d'appeler du code à distance. L'implémentation se trouve du côté du serveur et le rôle de RMI est de lier les interfaces côté client aux implémentations distantes. Concrètement, il faut définir l'interface de l'objet distant, l'implémentation, l'application serveur et l'application cliente.</p>
    <p>Le RMI permet de créer un objet distant sur une machine serveur et de le rendre accessible aux autres machines. Une machine cliente peut récupérer une représentation locale de l'objet distant appelée talon ou <em>stub</em>. Le client utilise alors ce talon comme si l'objet distant était local.</p>
    <p>Il est donc nécessaire de disposer de deux objets :</p>
    <ul>
        <li>un Stub, objet côté client qui va rediriger l'appel vers le serveur</li>
        <li>un Skeleton, objet côté serveur qui sera atteint par le Stub</li>
    </ul>

    <img src="skeleton.png" width="300" height="250">

    <p>Cette technique offre pour avantages de mettre à jour le client de manière transparente et de masquer l'exécution distante du code tout en travaillant comme si l'exécution était locale.</p>

    <h4>Côté serveur</h4>

    <p>L'interface est l'entité partagée par les clients et le serveur. L'interface est présente côté client. L'interface de l'objet distant est connue des 2 côtés, client et seveur.</p>

    <pre>import java.rmi.*;

public interface Hello extends Remote {
    public void sayHello(String nom) throws RemoteException;
}</pre>

    <p>L'implémentation de l'interface se fait côté serveur et ne doit pas être présente côté client sous peine de perdre l'utilité de RMI. Le talon implémente l'interface de l'objet distant pour le client et le squelette utilise la même interface pour transmettre les appels à l'objet distant.</p>

    <pre>import java.rmi.server.UnicastRemoteObject;
import java.rmi.*;

public class HelloImpl extends UnicastRemoteObject implements Hello {
    public HelloImpl() throws RemoteException {
        super();
    }
    public void sayHello(String nom) throws RemoteException {
        System.out.println("Hello "+nom");
    }
}</pre>

    <p>Dans la classe principale côté serveur, il faut instancier l'implémentation, créer le skeleton puis publier grâce au registry.</p>

    <pre>import java.rmi.*;
import java.net.*;

class HelloServer {
    public static void main(String[] args) {
        try {
            HelloImpl obj = new HelloImpl();
            Naming.rebind("Hello", obj);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}</pre>

    <h4>Côté client</h4>

    <p>L'appel côté client d'une méthode d'un objet distant consiste à obtenir une référence sur l'objet distant puis à appeler la méthode à partir de cette référence.</p>
    <pre>import java.rmi.*;
import java.net.*;

class HelloClient {
    public static void main(String[] args) {
        try {
            Hello obj = (Hello) Naming.lookup("//"+args[0]+"/Hello");
                obj.sayHello("Mike");
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
    }
}</pre>

    <hr>

    <!-- JMS -->

    <h3>JMS</h3>

    <p>JMS Java Message Service est une interface de programmation API spécialisée dans la création, l'envoi et la lecture de messages. JMS s'apparente donc à un service de messagerie permettant d'envoyer des messages d'une application à une autre sur un poste distant. Les particularités de JMS sont les suivantes :</p>
        <ul>
            <li>asynchrone, un message arrivera au client sans qu'il n'ait fait de requête</li>
            <li>fiable, il s'assure que le message soit délivré</li>
        </ul>

    <p>La communication par message est implantée par un bus de messages ou MOM Message Oriented Middleware.</p>

    <p>JMS contient les rôles suivants :</p>
    <ul>
        <li>le fournisseur JMS est la plateforme de messagerie</li>
        <li>les clients JMS produisent et consomment des messages</li>
        <li>les messages contiennent des informations communiquées entre les clients</li>
        <li>les objets administrés sont configurés par un administrateur</li>
    </ul>

    <p>Il existe 2 types de domaines de messagerie avec JMS, la communication point à point et la communication événementielle. Chacun de ces modes de communication utilise des objets intermédiaires par lesquels transitent les messages, appelés MOM Message Oriented Middleware. De ce fait, il est inutile d'établir une connexion entre un émetteur et un récepteur.</p>

    <p>Dans la communication point à point l'objet intermédiaire est une file d'attente (queue). plusieurs émetteurs peuvent envoyer sur la même file d'attente mais un seul destinataire peut consommer le message. On parle de communication N à 1.</p>

    <p>Dans la communication événementielle l'objet intermédiaire est un sujet (topic). Les émetteurs envoient leurs messages sur un topic. Les récepteurs s'inscrivent au topic pour recevoir les messages publiés sur ce topic.</p>

    <p>L'utilisation du bus de messages permet de mettre en place des services qui n'existaient pas en communication directe :</p>
    <ul>
        <li>transaction : envoi et réception groupés</li>
        <li>persistance : retransmission des messages en cas de panne</li>
        <li>multicast : communication de groupe</li>
        <li>log : trace des échanges</li>
        <li>gestion des droits d'accès</li>
    </ul>

    <p>Les MOM s'appuient sur le protocole TCP/IP qui lui-même s'appuie sur les sockets.</p>

    <p>Les ConnectionFactory sont des objets qui permettent de créer une connexion au provider.</p>

    <p>Exemple de bus de messages : ActiveMQ de Apache.</p>

    <h4>Construction d'un service de messagerie avec JMS 2</h4>

<pre>JMSConnectionFactory factory = new JMSConnectionFactory("tcp://localhost:61616");

@Resource(lookup = "jms/MyQueue");  // dans le cas d'un queue
public static Queue queue;

@Resource(lookup = "jms/MyTopic");  // dans le cas d'un topic
public static Topic topic;

JMSContext context = connectFactory.createContext();

JMSProducer producer = connectionFactory.createProducer(dest);

JMSConsumer consumer = context.createConsumer(dest);

producer.send(queue, "hello world");

Message m = consumer.receive();

context.createProducer().send(dest, message);

Listener myListener = new Listener();
consumer.setMessageListener(myListener);

class MyListener implements MessageListener {
    public void onMessage(Message msg) {
    System.out.println(((TextMessage)msg).getText());
    }
}
</pre>

    <h4>Construction d'un service de messagerie avec JMS 1</h4>

    <pre>properties.put("java.naming.factory.initial", "org.apache.activemq.jndi.ActiveMQInitialContextFactory");
properties.put("connectionFactory.ConnectionFactory", "tcp://localhost:61616");
InitialContext ic = new InitialContext(properties);
ConnectionFactory connectFactory = (ConnectionFactory) ic.lookup("ConnectionFactory");

props.put("topic.MyTopic", "MyTopic");      // dans le cas d'un topic
Topic topic = (Topic) ctx.lookup("MyTopic");

props.put("queue.MyQueue", "MyQueue");      // dans le cas d'un queue
Queue queue = (Queue) ctx.lookup("MyQueze");

Connection connect = connectFactory.createConnection("identifiant", "pw");
Session sess = connect.createSessions(false, Session .AUTO_ACKNOLEDGE);

MessageProducer producer = sess.createProducer(dest);

MessageConsumer consumer = sess.createConsumer(dest);

producer.send(queue, "hello world");

Message m = consumer.receive();

context.createProducer().send(dest, message);

Listener myListener = new Listener();
sess.setMessageListener(myListener);

class MyListener implements MessageListener {
    public void onMessage(Message msg) {
    System.out.println(((TextMessage)msg).getText());
    }
}</pre>


    <hr>

    <!-- Les services Web -->

    <h3>Les services Web</h3>

    <p>Les services Web sont un ensemble de technologies permettant l'invocation de méthodes distantes. La communication et l'échange de données sont basés sur les standard Web HTTP et XML. Il existe 2 familles de services Web.</p>

    <p>SOAP Simple Object Access Protocol est un protocole de RPC Remote Procedure Call orienté objet et basé sur XML qui permet la transmission de messages entre objets distants. Le transfert se fait par le protocole HTTP ou SMTP. XML est déjà utilisé pour stocker et organiser les informations des requêtes. Un message SOAP est un document XML qui sert d'enveloppe à une en-tête et un corps de message.</p>
    <p>SOAP permet l'interopérabilité entre différentes plate-formes.</p>

    <p>Dans le cas de l'envoi d'une image, on peut utiliser un message MIME Multimedia Internet Mail Extension comme attachement d'un message SOAP.</p>

    <p>Le client a besoin de la description détaillée du service Web qu'il veut utiliser avant de pouvoir interagir. Cette description est donnée par le WSDL Web Service Description Langage dans un document XML. WSDL est en fait un contrat entre un client et un serveur.</p>

    <p>L'annuaire des services UDDI Universal Description Discovery and Integration est un standard pour l'enregistrement et la publication des informations sur les services Web. Une entrée du répertoire UDDI est constituée d'un fichier XML.</p>

    <p>Pour développer un service Web, nous pouvons utiliser JAX-WS intégré dans Java.</p>
     arret p87
</section>

<footer>
</footer>

</body>
</html>

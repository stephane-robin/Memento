<!DOCTYPE HTML>
<html>
<head>
  <title> Memento </title>
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="prism.css">
  <meta charset="utf-8">
</head>

<!-- script de gestion des couleurs de code -->
<script defer src="prism.js"></script>

<!-- script de gestion de l'apparition du contenu d'une section -->
<script type="text/javascript">
function affichageConditionnel(bouton, id) {
    var div = document.getElementById(id);
    if(div.style.display=="none") { // si le div est masqué, on l'affiche et on change le contenu du bouton
        div.style.display = "block";
        bouton.innerHTML = "-";
    } else { // s'il est visible, on le masque et on change le contenu du bouton
        div.style.display = "none";
        bouton.innerHTML = "+";
    }
}</script>

<body>

<header>
  <div class="heroImage">
    <div class="heroTexte">
      <h2> Java </h2>
    </div>
  </div>
</header>

<div id="bandeau">
  <div id="titre"> <h1> Memento </h1> </div>
  <nav>
    <div class="element"> <a href="index.html">HTML</a> </div>
    <div class="element"> <a href="css.html">CSS</a> </div>
    <div class="element"> <a href="javascript.html">JAVASCRIPT</a> </div>
    <div class="element"> <a href="python.html">PYTHON</a> </div>
    <div class="element"> <a href="java.html">JAVA</a> </div>
    <div class="element"> <a href="c.html">C</a> </div>
    <div class="element"> <a href="git.html">GIT</a> </div>
  </nav>
</div>

<section id="principal">

    <div class="bloc">

        <div class="gauche">
            <p>Java est un langage orienté objet qui utilise un compilateur (javac) puis une machine virtuelle
                compatible toutes plateformes JVM Java Virtual Machine pour interpréter le Byte code. De ce fait,
                c'est un langage offrant une grande portabilité.
                C’est un langage à la fois compilé et interprété. Il est donc plus rapide que Python (interprété) mais
                plus lent que C++ (compilé).</p>
        </div>

        <div class="droite">
            <img src="java.png" width="60" height="100">
        </div>

    </div>

    <p style="font-weight:bold"> Table des matières :</p>
        <ul>
            <li> <a href="#javaterminal">Exécuter Java au Terminal</a></li>
            <li> <a href="#dates">Les dates</a></li>
            <li> <a href="#programmationreseau">La programmation réseau</a> </li>
            <li> <a href="#programmationclientserveur">Programmation client-serveur</a> </li>
            <li> <a href="#proxys">Les proxys</a> </li>
            <li> <a href="#mecanismermi">Le mécanisme RMI</a></li>
            <li> <a href="#jms">JMS</a></li>
            <li> <a href="#servicesweb">Les services Web</a></li>
        </ul>



    <!-- EXECUTER JAVA AU TERMINAL ================================== -->

    <h3 id="javaterminal">Exécuter Java au terminal <button type="submit" onclick="affichageConditionnel(this,'javaterminal_cache');"> + </button></h3>

    <div id="javaterminal_cache" style="display:none;">

    <p>Pour exécuter un programme Java en utilisant le terminal, il faut d'abord se rendre dans le dossier comportant le fichier, puis compiler le programme avec la commande</p> <pre><code class="language-javascript">javac monFichier.java</code></pre> <p>Le fichier se transforme alors en binaire exécutable par la Machine Virtuelle Java : monFichier.class. Pour exécuter ce programme il reste maintenant à utiliser la commande</p> <pre><code class="language-javascript">java monFichier</code></pre>

        <p>Notons que <em>java -version</em> en ligne de commande permet de vérifier que Java est bien installé.</p>
    </div>


    <!-- LES DATES -------------------------------------------------->

    <h3 id="#dates">Les dates<button type="submit" onclick="affichageConditionnel(this,'dates_cache');"> + </button></h3>

    <div id="dates_cache" style="display:none;">

        <h4>La classe GregorianCalendar</h4>

    <p>L'utilisation de la classe Date est obsolète. Il est préférable d'utiliser la classe GregorianCalendar qui hérite de la classe abstraite Calendar.</p>
    <p>On peut afficher le timestamp du moment sans formattage particulier en utilisant</p>
    <pre><code class="language-javascript">new GregorianCalendar().getTime()</code></pre>

    <p>Pour instancier une date à la date du jour, on utilise</p>
    <pre><code class="language-javascript">GregorianCalendar date = new GregorianCalendar();</code></pre>

    <p>Pour instancier une date à la date du 03/06/2018</p>
    <pre><code class="language-javascript">GregorianCalendar date = new GreogorianCalendar(2018,05,03);</code></pre>
    <p>car les mois sont notés de 0 à 11.</p>

    <p>Les différents éléments de date sont les suivants :</p>
    <pre><code class="language-javascript">date.get(Calendar.YEAR);
date.get(Calendar.MONTH);
date.get(Calendar.DAY_OF_MONTH);
date.get(Calendar.DAY_OF_WEEK);</code></pre>

    <p>On remarque que Calendar.YEAR concerne la classe Calendar et non l’objet date. On peut modifier la date prise en compte dans l’objet date de la façon suivante :</p>
    <pre><code class="language-javascript">date.set(Calendar.YEAR, annee);
date.set(Calendar.MONTH, mois);
date.set(Calendar.DAY_OF_MONTH, jour);
date.set(Calendar.DAY_OF_WEEK, jourDeLaSemaine);</code></pre>

    <fieldset><legend>ATTENTION</legend><p> Calendar.MONTH va de 0 à 11, et 0 est donc le mois de janvier. Calendar.DAY_OF_WEEK va de 1 à 7, et 1 est donc dimanche.</p></fieldset>

    <p>Toutefois, si on veut afficher correctement la date, on peut utiliser</p>
    <pre><code class="language-javascript">System.out.printf("%04d,%02d,%02d,%02d\n",annee,mois,jour,jourSemaine);</code></pre>

    <p>ou encore formatter de la façon suivante :</p>
    <pre><code class="language-javascript">SimpleDateFormat formattage = new SimpleDateFormat("yyyy-MM-dd-EEEE");
System.out.println(formattage.format(date.getTime()));</code></pre>

    <p><em>Exemple de saisie clavier de date puis affichage de la date saisie :</em></p>

    <pre><code class="language-javascript">Scanner saisie = new Scanner(System.in);
System.out.println("entrez année");
int annee = saisie.nextInt();
System.out.println("entrez mois");
int mois = saisie.nextInt();
System.out.println("entrez jour");
int jour = saisie.nextInt();

GregorianCalendar date = new GregorianCalendar(annee,mois,jour);
date.set(Calendar.MONTH, mois-1);
SimpleDateFormat formattage = new SimpleDateFormat("yyyy-MM-dd-EEEE");
System.out.println(formattage.format(date.getTime()));</code></pre>

        <h4>Répétition d'une instruction à l'aide d'un thread</h4>

        <p><em>La classe Timer :</em></p>
        <pre><code class="language-javascript">import java.util.*;</code></pre>

        <p>Pour répéter une action à intervalles réguliers, on peut utiliser l'équivalent d'un thread avec la classe Timer.</p>

        <pre><code class="language-javascript">public class Principale {
    public static void main(String[] args) {
        Timer timer = new Timer();
        TimerTask tache = new Action();
        timer.schedule(tache, 2000, 10); // toutes les 2000 ms, 10 répétitions
    }
}</code></pre>

        <p>et la tâche à effectuer plusieurs fois :</p>

        <pre><code class="language-javascript">public class Action extends TimerTask{
    public void run(){
        System.out.println("hello world");
    }
}</code></pre>

        <p><em>Directement avec la classe Thread :</em></p>
        <p>On peut également obtenir le même résultat sans la classe <em>Timer</em> en utilisant un thread.</p>

        <pre><code class="language-javascript">public class Principale {
    public static void main(String[] args) {
        Action t = new Action();
        t.start();
    }
}</code></pre>

        <p>et la tâche à effectuer plusieurs fois :</p>
        <pre><code class="language-javascript">public class TimeThread extends Thread {
    public void run(){
        for(int i=0; i<10; i++) { // 10 répétitions
            try {
                Thread.sleep(2000); // toutes les 2000 ms
                System.out.println("hello world");
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}</code></pre>

    </div>



    <!------------- GESTION DES EXCEPTIONS ----------------------->

    <h3>Gestion des exceptions<button type="submit" onclick="affichageConditionnel(this,'gestionexceptions_cache');"> + </button></h3>

    <div id="gestionexceptions_cache" style="display:none;">

    <p>La gestion des exceptions assure l'exécution continue du programme. Elle consiste à repérer un morceau de code qui pourrait générer une erreur, et donner une suite d'instructions à suivre en cas d'erreur pour éviter que le programme s'arrête brutalement.</p>

        <pre><code class="language-javascript">import java.util.*;</code></pre>

        <p>L'utilisation des mot-clés <em>try-catch-finally</em> gère l'exception. <em>try</em> entoure l'exception, <em>catch</em> indique les instructions à suivre en cas d'erreur, <em>finally</em> est facultatif et indique les instructions à suivre dans tous les cas. La gestion des exceptions peut également servir à analyser les causes de l'erreur.</p>

        <pre><code class="language-javascript">int j = 20, i = 0;
try {
    System.out.println(j/i);
} catch (ArithmeticException e)
    System.out.println("division par zéro");
}</code></pre>

        <p>L'utilisation du mot-clé <em>throws</em> dans une méthode rejette la gestion de l'exception à la classe qui appelle cette méthode.</p>

        <p>Dans l'exemple suivant, la gestion de l'exception dans le constructeur de Personne est laissée à la classe Principale.</p>

        <pre><code class="language-javascript">public class Personne {
    public int age = 0;
    public Personne(int age) throws Exception {
       this.age = age;
    }
}

public class Principale {
    public static void main(String[] args) {
        try {
            Personne p = new Personne("Edouard");
            int ageRecherche = p.age - 3; // l'age de la personne il y a 3 ans
        } catch (Exception e) {
            e.printStackTrace();
            e.getClass().getName() + " : " + e.getMessage();
        }
    }
}</code></pre>

<p>Notons la différence entre une erreur de compilation (détectée à l'analyse statique sans exécution du code) et une erreur d'exécution. La levée d'une exception ne concerne que les erreurs d'exécution.</p>




    </div>

    <!------------- LES TABLEAUX ----------------------------->

    <h3>Les tableaux<button type="submit" onclick="affichageConditionnel(this,'tableaux_cache');"> + </button></h3>

    <div id="tableaux_cache" style="display:none;">

        <p>Les tableaux sont des éléments de stockage statiques, dont la taille ne doit pas varier. Ainsi, on ne peut pas rajouter d'élément à un tableau sous peine d'en modifier totalement la structure. Les tableaux sont indexés à partir de 0 et n'admettent pas de système clé-valeur.</p>

        <pre><code class="language-javascript">import java.util.*;</code></pre>

        <h4>Déclaration d'un tableau</h4>

        <p>Un tableau doit être déclaré en indiquant le type d'objet qu'il contient. Il ne peut pas contenir des objets de types différents. Toutefois, on peut facilement déroger à cette règle en créant des tableaux de type Object qui est très large.</p>

        <pre><code class="language-javascript">Object[] tab = {"hello", 13, 's'};</code></pre>

        <p>Lors de la déclaration d'un tableau, doit être également précisé le nombre d'éléments qu'il contient. Le typage d'un élément et la taille du tableau ne pourront plus être modifiés ultérieurement.</p>

        <pre><code class="language-javascript">int[] tab = {12, 1, 34, 21};</code></pre>

        <p>Lors de la déclaration d'un tableau vide, tous les éléments sont initialisés automatiquement, les nombres à 0, les booleans à false, les objets et chaînes de caractères à null.</p>

        <pre><code class="language-javascript">int[] tab = new int[6];</code></pre>

        <h4>Affichage d'un tableau</h4>

        <pre><code class="language-javascript">for(int i=0; i&lt tab.length; i++){
    System.out.print(tab[i]+"\t");</code></pre>
        <p>ou encore</p>

        <pre><code class="language-javascript">for(String valeur : tab){
    System.out.print(valeur+"\t");</code></pre>

        <h4>Vector</h4>

        <p>La classe Vector, aujourd'hui désuète, permet de définir des tableaux utilisant des méthodes proches de celles des listes. Notons que la classe Vector est compatible avec la synchronisation à l'aide de threads. </p>


    </div>



    <!------------- LES COLLECTIONS ----------------------------->

    <h3>Les collections<button type="submit" onclick="affichageConditionnel(this,'listesdictionnaires_cache');"> + </button></h3>

    <div id="listesdictionnaires_cache" style="display:none;">

        <pre><code class="language-javascript">import java.util.*;</code></pre>

    <p>Les collections (ensemble, liste, dictionnaires) sont des conteneurs dynamiques pouvant accepter des objets de types différents et dont la taille varie.</p>

    <p>les ensembles contiennent des éléments non indexés et sans relation d'ordre. On ne peut donc pas y accéder en faisant référence à un String ou un index. Toutefois, on peut parcourir tout l'ensemble et vérifier si un terme appartient à cet ensemble. On les utilise essentiellement pour afficher les éléments d'un dictionnaire après avoir créé un ensemble de clés.</p>

    <p>Les listes contiennent des index auxquels sont associés une valeur unique. Elles s'apparentent à des tableaux sauf que leur taille peut varier et qu'elles peuvent contenir des éléments de types différents.</p>

    <p>Les dictionnaire contiennent des clés auxquelles sont associées une valeur unique.</p>

    <h4>Les listes</h4>

    <table>
        <tr><th>Objectif</th><th>Code</th></tr>
        <tr><td>définir une liste</td><td><pre>ArrayList maListe = new ArrayList();</pre></td></tr>
        <tr><td>définir une liste à partir d'un tableau</td><td><pre>String[] tableau = new String("toto", "tata");
ArraList maListe = new ArrayList(Arrays.asList(tableau));</pre></td></tr>
        <tr><td>définir une liste composée d'un seul type d'élément</td><td><pre>ArrayList&ltString&gt maListe = new ArrayList&ltString&gt();</pre></td></tr>
        <tr><td>ajouter l'élément <em>bonjour</em></td><td><pre>maListe.add("bonjour")</pre></td></tr>
        <tr><td>ajouter l'élément <em>bonjour</em> à l'emplacement d'indice 4</td><td><pre>maListe.add(4, "bonjour")</pre></td></tr>
        <tr><td>remplace l'élément d'indice 4 par <em>bonjour</em></td><td><pre>maListe.set(4, "bonjour")</pre></td></tr>
        <tr><td>renvoyer l'élément d'indice 4</td><td><pre>maListe.get(4)</pre></td></tr>
        <tr><td>renvoyer la taille de maListe</td><td><pre>maListe.size()</pre></td></tr>
        <tr><td>renvoyer l'indice de l'élément <em>bonjour</em></td><td><pre>maListe.indexOf("bonjour")</pre></td></tr>
        <tr><td>supprimer l'élément d'indice 4</td><td><pre>maListe.remove(4)</pre></td></tr>
        <tr><td>comparer l'élément d'indice 4 à celui d'indice 5</td><td><pre>maListe.get(4).equals(maListe.get(5)</pre></td></tr>
        <tr><td>tester si l'élément <em>bonjour</em> appartient à maListe</td><td><pre>maListe.contains("bonjour)</pre></td></tr>
        <tr><td>vider maListe</td><td><pre>maListe.clear()</pre></td></tr>
        <tr><td>copier par valeurs de maListe</td><td><pre>ArrayList listeCopie = (ArrayList) maListe.clone();</pre></td></tr>
    </table>

    <p>ArrayList ne fonctionne qu’avec des types objets pour produire des objets. Ainsi on ne peut pas avoir de liste avec des éléments de type int. Pour pallier ce problème, Java a prévu de faire correspondre à chaque type primitif un objet équivalent. Ainsi au type primitif int correspond l’objet Integer, au type primitif double correspond le type complexe Double. L'autoboxing permet de passer d'un type primitif à son objet correspondant de façon automatisée. En revanche, il convient de déclarer les listes avec les types objet et non les types primitifs. On écrira ainsi :</p>
        <pre><code class="language-javascript">ArrayList&ltInteger&gt maListe = new ArrayList&ltInteger&gt();</code></pre>

    <p>Attention, la comparaison de 2 éléments ne se fait pas avec l'opérateur == car on compare des objets et non des types primitifs.</p>
    <p>Pour afficher une liste :</p>

        <pre><code class="language-javascript">Iterator iterateur = maListe.iterator();
while(iterateur.hasNext()) {
    System.out.print(iterateur.next()+"\t");
}</code></pre>

        <pre><code class="language-javascript">for(int i=0; i&ltmaListe.size();i++) {
    System.out.print(maListe.get(i)+"\t");
}</code></pre>

    <h4>Les dictionnaires</h4>

        <table>
            <tr><th>Objectif</th><th>Code</th></tr>
            <tr><td>définir un dictionnaire</td><td><pre>HashMap dico = new HashMap();</pre></td></tr>
            <tr><td>définir une liste composée d'un type d'élément spécifique</td><td><pre>HashMap&ltString, String&gt dico = new HashMap&ltString, String&gt();</pre></td></tr>
            <tr><td>ajouter l'élément <em>lundi, Monday</em></td><td><pre>dico.put("lundi", Monday)</pre></td></tr>
            <tr><td>remplace l'élément de clé <em>lundi</em></td><td><pre>dico.put("lundi", "Montag")</pre></td></tr>
            <tr><td>renvoyer la valeur de l'élément de clé <em>lundi</em></td><td><pre>dico.get("lundi")</pre></td></tr>
            <tr><td>renvoyer la taille de dico</td><td><pre>dico.size()</pre></td></tr>
            <tr><td>supprimer l'élément de clé <em>lundi</em></td><td><pre>dico.remove("lundi")</pre></td></tr>
            <tr><td>vider dico</td><td><pre>dico.clear()</pre></td></tr>
        </table>

        <p>Pour afficher un dictionnaire :</p>

        <pre><code class="language-javascript">HashMap dico = new HashMap();
Set ensemble = dico.keySet();
for(Object clef : ensemble){
    System.out.println(clef+" :"dico.get(clef));
}</code></pre>

        <pre><code class="language-javascript">Iterator iterateur = ensemble.iterator();
while(iterateur.hasNext()) {
Object clef = iterateur.next();
    System.out.println(clef+":"+dico.get(clef));
}</code></pre>

    </div>


    <!-- ===== LA PROGRAMMATION RESEAU =================================== -->

<h3 id="programmationreseau">La programmation réseau<button type="submit" onclick="affichageConditionnel(this,'programmationreseau_cache');"> + </button></h3>

    <div id="programmationreseau_cache" style="display:none;">

<h4>Rappels sur les réseaux</h4>

<p>La communication réseau est initialement définie par le modèle OSI en 7 couches. Toutefois, la plupart des logiciels reposent sur le modèle TCP/IP en 4 couches : réseau, Internet, transport, application. C'est dans cette dernière couche du modèle TCP/IP que se positionne Java.</p>
<p>Notons que par défaut les principaux protocoles de transfert utilisent les ports suivants :</p>
<ul>
    <li>http : port 80</li>
    <li>ftp : port 20 ou 21</li>
    <li>smtp : port 25</li>
</ul>

<h4>La classe InetAddress</h4>

        <pre><code class="language-javascript">import java.net.*;</code></pre>
<p>Pour manipuler des adresses IP, on utilise la classe InetAddress. Par exemple pour obtenir l'adresse IP d'un site connu par son nom de domaine :</p>
<pre><code class="language-javascript">try{
    InetAddress adresse = InetAddress.getByName("meteocentrale.ch");
}catch (UnknownHostException e) {
    e.printStackTrace();
}</code></pre>

<p>et pour connaître l'adresse IP de <em>localhost</em> :</p>

    <pre><code class="language-javascript">try{
    InetAddress adresse = InetAddress.getByName("localhost");
}catch (UnknownHostException e) {
    e.printStackTrace();
}</code></pre>

    <p>Les méthodes associées à la classe InetAddress nécessitent également la gestion de UnknownHostException :</p>
<table>
    <tr><th>Objectif</th><th>Code</th></tr>
    <tr><td>nom de l'hôte (client)</td><td><pre>adresse.getHostName()</pre></td></tr>
    <tr><td>adresse IP</td><td><pre>adresse.getHostAddress()</pre></td></tr>
    <tr><td>teste si l'adresse est de type boucle locale</td><td><pre>adresse.isLoopbackAddress()</pre></td></tr>
</table>

    <p>Certains sites Internet peuvent avoir plusieurs adresses IP :</p>
<pre><code class="language-javascript">try{
    InetAddress[] adresses = InetAddress.getAllByName("amazon.fr");
    System.out.println("Toutes les adresses IP : ");
    for(InetAddress valeur : adresses) {
        System.out.println(" - " + valeur.getHostAddress());
    }
} catch(UnknownHostException e) {
    e.printStackTrace();
}</code></pre>

<h4>La classe URL</h4>

<p>On peut également utiliser la classe URL pour récupérer les données d'un site Internet :</p>
<pre><code class="language-javascript">import java.io.*;
import java.net.*;

try {
    URL url = new URL("http://www.meteofrance.fr");
}catch(MalformedURLException e) {
    e.printStackTrace();
}</code></pre>

    <p>Les méthodes associées à la classe URL nécessitent également la gestion de MalformedURLException.</p>

<table>
    <tr><th>Objectif</th><th>Code</th></tr>
    <tr><td>nom du site</td><td>url.getAuthority()</td></tr>
    <tr><td>port par défaut</td><td>url.getDefaultPort()</td></tr>
    <tr><td>nom de l'hébergeur</td><td>url.getHost()</td></tr>
    <tr><td>numéro de port spécifié</td><td>url.getPort()</td></tr>
    <tr><td>protocole</td><td>url.getProtocol()</td></tr>
</table>

<p>Lorsque url.getPort() renvoie -1, cela signifie que le port n'a pas été spécifié dans l'URL.</p>

<p>Pour vérifier qu'une saisie utilisateur correspond à une url, on peut par exemple utiliser la condition :</p>
<pre>if(host.matches("[a-zA-Z\\.]+"))</pre>

    </div>





    <!-- ===== LES PROXYS ======================================= -->

    <h3 id="proxys">Les proxys<button type="submit" onclick="affichageConditionnel(this,'proxys_cache');"> + </button></h3>

    <div id="proxys_cache" style="display:none;">

        <p>Un proxy constitue une autre façon de se connecter à un serveur. Le proxy est un intermédiaire faisant le lien entre le client et le serveur.</p>
        <pre><code class="language-javascript">import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.Proxy;
import java.net.Socket;
import java.net.SocketAddress;

//On crée une adresse correspondant à notre proxy
SocketAddress proxyAddress = new InetSocketAddress("10.10.10.10", 8080);

//On instancie la classe Proxy avec le type souhaité
Proxy proxy = new Proxy(Proxy.Type.SOCKS, proxyAddress);

//On crée notre socket utilisant le proxy
Socket s = new Socket(proxy);

//On crée l'adresse que l'on souhaite atteindre via le proxy
SocketAddress remote = new InetSocketAddress("www.adret-attitude.ch", 80);
try {
    //On connecte le tout !
    s.connect(remote);
} catch (IOException e) {
    e.printStackTrace();
}</code></pre>

        <p></p>

        <table>
            <tr><th>Objectif</th><th>Code</th></tr>
            <tr><td>port côté serveur</td><td>s.getPort()</td></tr>
            <tr><td>port côté client</td><td>s.getLocalPort()</td></tr>
            <tr><td>nom hôte distant</td><td>s.getInetAddress().getHostName()</td></tr>
            <tr><td>adresse hôte distant</td><td>s.getInetAddress().getHostAddress()</td></tr>
            <tr><td>adresse socket hôte distant</td><td>s.getRemoteSocketAddress()</td></tr>
        </table>

        <pre><code class="language-javascript">try {
    Socket s = new Socket("www.adret-attitude.ch", 80);
    System.out.println("Port de communication côté serveur : " + s.getPort());
    System.out.println("Port de communication côté client : " + s.getLocalPort());
    System.out.println("Nom de l'hôte distant : " + s.getInetAddress().getHostName());
    System.out.println("Adresse de l'hôte distant : " + s.getInetAddress().getHostAddress());
    System.out.println("Adresse socket de l'hôte distant : " + s.getRemoteSocketAddress());
} catch (UnknownHostException e) {
        e.printStackTrace();
} catch (IOException e) {
        e.printStackTrace();
}</code></pre>

    </div>





<!-- ===== LES SOCKETS =================================== -->

<h3 id="programmationclientserveur">Les sockets<button type="submit" onclick="affichageConditionnel(this,'programmationclientserveur_cache');"> + </button></h3>

    <div id="programmationclientserveur_cache" style="display:none;">

        <div class="pcle"><strong>API Application Programming Interface</strong> : ensemble normalisé de classes, de méthodes qui sert de façade par laquelle un logiciel offre des services à d'autres logiciels. C'est la partie du programme qu'on expose au monde extérieur pour manipuler celui-ci. Ces services sont offerts à travers une bibliothèque ou un service Web. L'API est au développeur ce que l'User Interface est à l'utilisateur.</div>

    <p>Les sockets sont des API permettant de gérer les communications entre programmes au sein d'une structure client-serveur. La communication avec sockets nécessite la connaissance d'adresses, de ports, et l'utilisation de protocoles (TCP ou UDP). Une même socket sert aussi bien à envoyer qu'à recevoir des données. Les sockets travaillent en full-duplex, i.e. le client et le serveur peuvent envoyer et recevoir des signaux simultanément. Il n'y a donc pas de file d'attente. Notons également que le protocole TCP/IP s'appuie sur les sockets.</p>

    <p>Une socket est identifiée de manière unique par l'adresse IP de la machine suivie du numéro de port utilisé, ce dernier étant compris entre 1024 et 65536.</p>

        <pre><code class="language-javascript">import java.io.*;
import java.nio.*;
import java.util.*;
import java.net.*;</code></pre>

        <h4>Fonctionnement d'une communication par Sockets</h4>

    <p>Le serveur crée une socket de connexion sur un port défini, puis attend la demande de communication venant d'un client pour ouvrir une socket de communication. De son côté, le client crée une socket de communication à l'adresse du serveur et sur le port défini.</p>

        <img src="socket.png" height="300" width="750">

        <p>Une communication par Sockets est donc structurée de la façon suivante :</p>
        <ul>
            <li>une classe Server comprenant une socket de connexion et une socket de communication</li>
            <li>une classe Client comprenant une socket de communication</li>
        </ul>

        <img src="socketChaine.png">

        <h4>Tester les ports disponibles du client</h4>

        <p>Pour tester les 1024 premiers ports du client à l'aide de cette classe :</p>
        <pre><code class="language-javascript">for(int i = 1; i <= 1024; i++){
    try {
        Socket soc = new Socket("127.0.0.1", i);  // 127.0.0.1 est l'adresseIP de localhost
        System.out.println("La machine autorise les connexions sur le port : " + i);
    } catch (IOException e) {
        System.out.println("Le port "+i+" n'est pas ouvert ou n'est pas autorisé.");
    }
}</code></pre>

    <h4>Le mode connecté</h4>

    <p>En mode connecté, deux sockets établissent une communication durable qui permet d'éviter de transmettre l'identité de la socket destinatrice à chaque envoi. Dans ce cas, un des programmes prend le rôle du serveur et l'autre le rôle du client. Le serveur est donc vu comme un programme rendant des services aux clients. Le mode connecté utilise le protocole TCP.</p>
    <fieldset><legend>IMPORTANT</legend><p>La socket côté serveur doit être lancée avant la socket côté client.</p></fieldset>

    <p>Le serveur utilise la fonction bloquante accept(), qui ne libère pas le programme tant qu'elle n'a pas reçu de demande de communication.</p>

    <p>Les méthodes de la classe Socket permettant d'obtenir des informations sur la connexion et nécessitent également la gestion de IOException :</p>

    <table>
        <tr><th>Instruction</th><th>Résultat</th></tr>
        <tr><td><pre><code class="language-javascript">socket_client.getInetAddress()</code></pre></td><td>fournit l'adresse IP distante</td></tr>
        <tr><td><pre><code class="language-javascript">socket_client.getLocalAddress()</code></pre></td><td>fournit l'adresse IP locale</td></tr>
        <tr><td><pre><code class="language-javascript">socket_client.getPort()</code></pre></td><td>fournit le nmr de port distant</td></tr>
        <tr><td><pre><code class="language-javascript">socket_client.getLocalPort()</code></pre></td><td>fournit le nmr de port local</td></tr>
    </table>

    <p>La machine virtuelle Java ferme les sockets non utilisés à la fin de l'exécution du programme. Toutefois, le nombre de sockets ouvertes par un programme est limité, ce qui conduit à des erreurs quand cette limite est atteinte. La méthode close() permet de fermer la connexion.</p>

        <p>Pour l'envoi de messages : <em>dis.writeUTF("hello")</em>, <em>dis.writeInt(12)</em> ou <em>ois.writeObject(obj)</em> </p>
        <p>Pour la réception de messages : <em>dos.readUTF()</em>, <em>dos.readInt()</em> ou <em>oos.readObject()</em></p>

        <h4>Exemple de transmission d'une chaîne de caractères par TCP :</h4>

        <p>Il n'est pas nécessaire de transmettre la taille des String avec le message lorsqu'on utilise les méthodes writeUTF() et readUTF() qui détectent automatiquement la taille des String dans un flux. La quantité d'information transmise est donnée par message.length() si on note message la variable représentant le message reçu.</p>

        <p>Dans cet exemple, un client transmet une chaîne de caractères au serveur.</p>

        <p><em>Côté serveur</em></p>

        <pre><code class="language-javascript">public class ServeurTCP {

    public static void main(String[] args) {
        try {
            // creation socket serveur de connexion sur le port 5555
            ServerSocket srv = new ServerSocket(5555);
            // creation socket serveur de communication a la demande d'un client
            Socket com = srv.accept();
            // creation objet communication entrante en provenance du client
            DataInputStream dis = new DataInputStream(com.getInputStream());

            System.out.println("Message reçu : " + dis.readUTF());

            // fermeture connexion
            com.close();
            srv.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

        <p><em>Côté client</em></p>

        <pre><code class="language-javascript">public class ClientTCP {

    public static void main(String[] args) {
        try {
            // creation socket client de communication sur le port 5555
            // Socket clt = new Socket("adresseServeur", 5555); ou
            Socket clt = new Socket("nomHote", 5555);
            // communication sortante vers le serveur
            DataOutputStream dos = new DataOutputStream(clt.getOutputStream());

            dos.writeUTF("hello world");

            // fermeture connexion
            clt.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

        <h4>Exemple de transmission d'un entier par TCP :</h4>

        <p>Dans cet exemple un serveur transmet un entier à un client.</p>

        <p><em>Côté serveur</em>  </p>

        <pre><code class="language-javascript">public class ServeurTCP {

    public static void main(String[] args) {
        try {
            ServerSocket srv = new ServerSocket(5555);
            Socket com = srv.accept();

            DataOutputStream dos = new DataOutputStream(com.getOutputStream());
            dos.writeInt(1420);

            com.close();
            srv.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

        <p><em>Côté client</em> </p>

        <pre><code class="language-javascript">public class ClientTCP {

    public static void main(String[] args) {
        try {
            Socket clt = new Socket("nomHote", 5555);
            DataInputStream dis = new DataInputStream(clt.getInputStream());

            System.out.println("Message received: " + dis.readInt());

            clt.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

        <h4>Exemple de transmission d'un objet par TCP :</h4>

        <img src="socketObjet.png">

        <p>Dans cet exemple, un client transmet un objet sous forme de message au serveur.</p>

        <p><em>Côté serveur</em> </p>

        <pre><code class="language-javascript">public class ServeurTCP {

    public static void main(String[] args) {

        try {
            ServerSocket srv = new ServerSocket(5555);
            Socket com = srv.accept();
            // communication entrante, les data sont placees dans un objet
            // transforme en Message, puis en String pour affichage
            DataInputStream dis = new DataInputStream(com.getInputStream());
            ObjectInputStream ois = new ObjectInputStream(dis);

            ObjetEchange obj = (ObjetEchange) ois.readObject();
            System.out.println("Message reçu : " + obj.toString());

            com.close();
            srv.close();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) { // doit apparaitre
            e.printStackTrace();
        }
    }
}</code></pre>

        <p><em>Côté client</em></p>

        <pre><code class="language-javascript">public class ClientTCP {

    public static void main(String[] args) {
        ObjetEchange obj = new ObjetEchange("steph",new Date(), "hello world");

        try {
            Socket clt = new Socket("nomHote", 5555);
            // communication sortante, les data sont placees dans un objet transmis sous forme de Message
            DataOutputStream dos = new DataOutputStream(clt.getOutputStream());
            ObjectOutputStream  oos = new ObjectOutputStream(dos);

            oos.writeObject(obj);

            clt.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

        <p>et la classe ObjetEchange présente côté serveur et côté client, qui implémente l'interface Serializable nécessaire pour transmettre le message sous forme de data :</p>

        <pre><code class="language-javascript">public class ObjetEchange implements Serializable{
    // un objet de type ObjetEchange doit etre serialisable pour pouvoir etre transmis
    String name;
    Date date;
    String msg;

    public ObjetEchange(String name, GregorianCalendar date, String msg){
        this.name = name;
        this.date = date;
        this.msg = msg;
    }

    @Override
    public String toString(){
        return "message = [ " + name + " , " + date.getTime()+" , "+msg +" ]";
    }
}</code></pre>

        <h4>Exemple de serveur connecté dynamiquement à plusieurs clients par TCP :</h4>

        <p>Dans cet exemple, 10 clients transmettent une chaîne de caractère au serveur.</p>

        <p>Le serveur ne traite qu'un seul client à la fois. Si ce traitement prend du temps, les autres clients peuvent être bloqués. Pour éviter ce problème, la gestion des connexions peut être pilotée par des threads. On peut utiliser un le pool de threads qui arrête les sockets de communication des threads ayant terminé leurs traitements pour passer la main aux threads suivants. Dans ce cas, les échanges avec les clients sont uniques puisque les communications sont interrompues. On peut également utiliser une création dynamique de threads au fur et à mesure des besoins. Dans ce cas, la communication peut être maintenue L'inconvénient est la possibilité de créer une infinité de threads ou encore de créer</p>

        <p><em>Côté serveur</em></p>

        <pre><code class="language-javascript">public class ServeurTCP {
    public static void main(String[] args) {
        try {
            ServerSocket srv = new ServerSocket(5555);

            for(int i=0; i<10; i++){ // pour 10 clients
                Socket com = srv.accept();

                ServerThread t = new ServerThread(com);
                t.start();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

public class ServerThread extends Thread { // gestion des threads pour chaque communication
    Socket com;

    public ServerThread(Socket com) {
        this.com = com;
    }

    public void run() {
        try{
            DataInputStream dis = new DataInputStream(com.getInputStream());
            while(!fin){
                dis.readUTF();
            }
            com.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

        <p><em>Côté client</em></p>

        <pre><code class="language-javascript">public class ClientTCP {

    public static void main(String[] args) {
        try {
            Socket clt = new Socket("nomServeur", 5555);
            DataOutputStream dos = new DataOutputStream(clt.getOutputStream());

            dos.writeUTF("hello world");

            clt.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>


        <h4>Exemple de serveur connecté par un pool de threads à plusieurs clients par TCP :</h4>

        <p>Dans cet exemple, 10 clients transmettent une chaîne de caractère au serveur.</p>

        <p><em>Côté serveur</em></p>

        <p>Le serveur commence par créer un ensemble de threads en attente de recevoir une demande de connexion. Lorsqu'un client demande une connexion, elle est prise en charge par un des threads.</p>

        <img src="socketPool.png">

        <pre><code class="language-javascript">public class ServeurTCP {
    public static void main(String[] args) {
        try {
            ServerSocket srv = new ServerSocket(5555);
            ServerThread[] pool = new ServerThread[8]; // on choisit de travailler avec 8 threads

            for(ServerThread t : pool) {
                t = new ServerThread(srv);
                t.start();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

public class ServerThread extends Thread { // gestion des threads pour chaque communication
    ServerSocket srv;

    public ServerThread(ServerSocket srv) {
        this.srv = srv;
    }

    public void run() {
        try{
            for(int i=0; i<11; i++) { // on considère 10 clients
                Socket com = srv.accept();
                DataInputStream dis = new DataInputStream(com.getInputStream());

                while(!fin) {
                    dis.readUTF();
                }
                com.close();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

        <p><em>Côté client</em></p>

        <pre><code class="language-javascript">public class ClientTCP {

    public static void main(String[] args) {
        try {
            Socket clt = new Socket("nomServeur", 5555);
            DataOutputStream dos = new DataOutputStream(clt.getOutputStream());

            dos.writeUTF("hello world");

            clt.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

        <h4>Le mode non connecté</h4>

    <p>En mode non connecté, le destinataire de la socket est précisé à chaque envoi. La communication utilise dans ce cas le protocole UDP qui envoie des données au destinataire sans le prévenir et sans s'assurer qu'elles sont bien arrivées.</p>
<p>Notons que TCP est plus sécurisé que UDP et UDP est plus rapide que TCP.</p>

    <fieldset><legend>IMPORTANT</legend><p>En mode non connecté, le programme récepteur doit être lancé en premier.</p></fieldset>

        <p>Pour l'envoi de messages : <em>x.send(paquet)</em> </p>
        <p>Pour la réception de messages : <em>x.receive(paquet)</em> </p>

        <h4>Exemple de transmission d'une chaîne de caractères par UDP :</h4>

        <p>Dans cet exemple un client transmet une chaîne de caractères au serveur.</p>

        <p><em>Côté serveur</em> </p>

<pre><code class="language-javascript">public class ServerUDP {

    public static void main(String[] args) {
        // creation d'un buffer pour contenir le message a recevoir
        byte[] buffer = new byte[256];

        try {
            // creation de la socket de reception
            DatagramSocket srv = new DatagramSocket(5555);
            // creation et reception du paquet
            DatagramPacket paquet = new DatagramPacket(buffer, buffer.length);

            srv.receive(paquet);
            System.out.println("Message recu =  " + new String(buffer));

            srv.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

        <p><em>Côté client </em></p>

    <pre><code class="language-javascript">public class ClientUDP {

    public static void main(String[] args) {
        String message = "rendez-vous à 13h.";

        try {
            // creation de la socket emettrice
            DatagramSocket clt = new DatagramSocket();
            // recuperation de l'adresse IP
            InetAddress adresseIP = InetAddress.getByName("nomHote");
            // creation du packet et envoi du message
            DatagramPacket paquet = new DatagramPacket(message.getBytes(), message.getBytes().length, adresseIP, 5555);

            clt.send(paquet);

            clt.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

        <h4>Exemple de transmission d'un entier par UDP :</h4>

        <p>Dans cet exemple un serveur transmet un entier à un client.</p>

        <p><em>Côté serveur</em> </p>

<pre><code class="language-javascript">public class ServerUDP {

    public static void main(String[] args) {
        // transformation de l'entier en byte[]
        byte[] buffer =  ByteBuffer.allocate(4).putInt(1402).array();

        try {
            DatagramSocket srv = new DatagramSocket(5555);
            DatagramPacket paquet = new DatagramPacket(buffer, buffer.length);

            clt.send(paquet);

            srv.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

        <p><em>Côté client</em> </p>

<pre><code class="language-javascript">public class ClientUDP {

    public static void main(String[] args) {
        byte[] buffer = new byte[256];

        try {
            DatagramSocket clt = new DatagramSocket();
            InetAddress adresseIP = InetAddress.getByName("nomServeur");
            DatagramPacket paquet = new DatagramPacket(buffer, buffer.length, adresseIP, 5555);

            clt.receive(paquet);
            // conversion du message reçu en byte[] vers un entier
            System.out.println("Message reçu :  " + ByteBuffer.wrap(buffer).getInt());

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

    </div>



    <!-- Le RMI ------------------------------>

    <h3 id="mecanismermi">Le mécanisme RMI<button type="submit" onclick="affichageConditionnel(this,'mecanismermi_cache');"> + </button></h3>

    <div id="mecanismermi_cache" style="display:none;">

    <p>Le mécanisme RMI Remote Method Invocation permet d'appeler du code à distance, en créant un objet distant sur une machine serveur. Notons que l'appel à distance est bloquant. Cette technique offre pour avantages de mettre à jour le client de manière transparente et de masquer l'exécution distante du code tout en travaillant comme si l'exécution était locale.</p>

        <pre><code class="language-javascript">import java.rmi.*;
import java.rmi.server.*;
import java.util.*;
import java.io.*;
import java.net.*;</code></pre>

        <h4>Fonctionnement d'une communication par RMI</h4>

        <p>Le client utilise une représentation locale de l'objet distant appelée <em>stub</em>, qui utilise elle-même une représentation distante appelée <em>skeleton</em> présente sur le serveur. Le client utilise alors ce <em>stub</em> comme si l'objet distant était local. Ils sont transparents pour le programmeur car ils n'apparaissent pas dans les différentes classes. En revanche, ils utilisent un serveur de nom, le <em>registry</em>, qui définit les liens entre <em>stub</em>, <em>skeleton</em> et l'interface. Le <em>registry</em> est créé en ligne de commande par l'instruction <em>rmiregistry</em>.</p>

        <p>Une communication par RMI est structurée de la façon suivante :</p>
        <ul>
            <li>une interface de l'objet distant</li>
            <li>une classe Implementation</li>
            <li>une classe Serveur contenant le <em>skeleton</em></li>
            <li>une classe Client contenant le <em>stub</em></li>
        </ul>

            <img src="rmi.png" width="900">

        <p>Pour l'envoi de messages : <em>obj.maMethode()</em> </p>

        <h4>Exemple de transmission d'une chaîne de caractères par RMI :</h4>

        <p>On présente ici une procédure où le client affiche <em>Hello Mike</em> en utilisant la procédure <em>sayHello</em> présente sur le serveur.</p>

        <p>L'interface est l'entité partagée par le client et le serveur. Il n'est pas nécessaire qu'elle soit présente des deux côtés. Seule sa présence côté serveur est requise car elle est accessible de chaque côté grâce au <em>registry</em>.</p>

    <pre><code class="language-javascript">public interface Hello extends Remote {
    public void sayHello(String nom) throws RemoteException;
}</code></pre>

    <p><em>Côté serveur :</em></p>

    <p>L'implémentation de l'interface se fait côté serveur et ne doit pas être présente côté client.</p>

    <pre><code class="language-javascript">public class Implementation extends UnicastRemoteObject implements Hello {
    public Implementation() throws RemoteException {
        super();
    }
    public void sayHello(String nom) throws RemoteException {
        System.out.println("Hello "+nom);
    }
}</code></pre>

    <p>Dans la classe principale côté serveur, il faut instancier l'implémentation, puis le <em>skeleton</em> est défini pour transmettre les appels à l'objet distant.</p>

    <pre><code class="language-javascript">public class Serveur {
    public static void main(String[] args) {
        try {
            // creation de l'objet distant
            Implementation objetDistant = new Implementation();
            // associe l'url de Hello a l'objet distant dans le registry, ce qui crée le skeleton
            Naming.rebind("Hello", objetDistant);
        } catch (RemoteException e) {
            e.printStackTrace();
        } catch (MalformedURLException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

        <p><em>Côté client :</em></p>

        <p>Le <em>stub</em> implémente l'interface de l'objet distant pour le client.</p>
    <p>L'appel côté client d'une méthode d'un objet distant consiste à obtenir une référence sur l'objet distant puis à appeler la méthode à partir de cette référence.</p>
    <pre><code class="language-javascript">public class Client {
    public static void main(String[] args) {
        try {
            // arg[0] represente l'url qui sera le 1er argument entre en ligne de commande
            // lors de l'exécution de java HelloClient localhost:5555, donc ici localhost
            // le fait de pointer vers l'adresse de l'interface Hello cree le stub
            Hello obj = (Hello) Naming.lookup("//"+args[0]+"/Hello");
            obj.sayHello("Mike");
        } catch (RemoteException e) {
            e.printStackTrace();
        } catch (NotBoundException e) {
            e.printStackTrace();
        } catch (MalformedURLException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

        <p>La gestion de sécurité se réalise à travers une instance de la classe java.rmi.RMISecurityManager, à la fois côté client et serveur :</p>
<pre><code class="language-javascript">if(System.getSecurityManager()==null){
    System.setSecurityManager(new RMISecurityManager());
}</code></pre>

<p>qui nécessite la bibliothèque :</p>
        <pre><code class="language-javascript">import java.lang.*;</code></pre>

        <p>Il faut ensuite rajouter dans le package courant le fichier <em>policy</em> suivant :</p>
        <pre><code class="language-javascript">grant{
    permission java.net.SocketPermission "*:1024-65535", connect,accept";
    permission java.net.SocketPermission "*:80", "connect";
}</code></pre>

        <p>ou encore pour tout permettre :</p>

        <pre><code class="language-javascript">grant{
    permission java.security.AllPermission;
}</code></pre>

<h4>Exemple d'une boite de messagerie par RMI :</h4>

        <p>Dans cet exemple, le client peut s'inscrire à un service de messagerie, envoyer un message composé de son nom, la date et le contenu, consulter le dernier message d'un client par son numéro de client.</p>

        <img src="rmiObjet.png">

<p><em>L'interface :</em></p>

<pre><code class="language-javascript">public interface Boite extends Remote{
    public int inscrire() throws RemoteException;
    public void envoyerMessage(int nmrClient, Message mess) throws RemoteException;
    public Message getMessage(int nmrClient) throws RemoteException;
}</code></pre>

    <p><em>Côté serveur :</em></p>

    <p>La classe Message :</p>
<pre><code class="language-javascript">public class Message implements Serializable{
    public String nom;
    public String mess;
    public GregorianCalendar date;

    public Message(String nom, GregorianCalendar date, String mess) {
        this.nom = nom;
        this.date = date.getTime();
        this.mess = mess;
    }

    @Override
    public String toString(){
        return "Le "+date+" "+nom+" a écrit : "+mess;
    }
}</code></pre>

        <fieldset><legend>ATTENTION</legend><p>Lors d'un appel distant les paramètres, les valeurs de retour et les exceptions sont transmis par copie et doivent donc être sérialisables. Or les types primitifs et les objets distants le sont par défaut. En revanche, les types créés ne sont pas sérialisables mais peuvent le devenir si les classes correspondantes implémentent l'interface Serializable.</p></fieldset>

        <p>l'implémentation :</p>
<pre><code class="language-javascript">public class Implementation extends UnicastRemoteObject implements Boite{
    public static int nmrClient;
    public Vector&ltMessage&gt vectMess; // la classe Vector est compatible avec les Threads

    public Implementation() throws RemoteException{
        super();
        nmrClient = 0;
        vectMess = new Vector(10);
    }

    public int inscrire() throws RemoteException{
        return nmrClient++;
    }

    public void envoyerMessage(int nmrClient, Message mess) throws RemoteException{
        vectMess.add(nmrClient, mess);
    }

    public Message getMessage(int nmrClient) throws RemoteException {
        return (Message)vectMess.get(nmrClient);
    }
}</code></pre>

    <p>et la classe principale :</p>
<pre><code class="language-javascript">public class Serveur {
    public static void main(String[] args){
        try{
            Implementation objDistant = new Implementation();
            Naming.rebind("Boite", objDistant);
        }catch(RemoteException e){
            e.printStackTrace();
        }catch(MalformedURLException e){
            e.printStackTrace();
        }
    }
}</code></pre>

    <p><em>Côté client :</em></p>

<pre><code class="language-javascript">public class Client {
    public static void main(String[] args){
        try{
            Boite obj = (Boite)Naming.lookup("//"+args[0]+"/Boite");
            int nmrClient = obj.inscrire();
            Message mess = new Message("Mike", new GregorianCalendar(), "hello world");
            obj.envoyerMessage(nmrClient, mess);
            System.out.println("Dernier message : "+obj.getMessage(nmrClient).toString());
        }catch(RemoteException e){
            e.printStackTrace();
        }catch(NotBoundException e){
            e.printStackTrace();
        }catch(MalformedURLException e){
            e.printStackTrace();
        }
    }
}</code></pre>

        <p>Si les objets distants attendent la connexion en permanence, les ressources mémoire sont monopolisées inutilement. Pour cette raison, on préfère créer des objets distants activables. L'utilisation de la classe UnicastRemoteObjetct est réservée au développement d'objets distants temporaires.</p>
        <p>Notons que l'application cliente devra également gérer la synchronisation des appels à distance à l'aide de threads pour éviter le blocage du système.</p>


        <p>La gestion de sécurité est modifiée pour pouvoir créer le groupe d'activation :</p>

        <pre><code class="language-javascript">grant{
    permission java.net.SocketPermission "machine:*", accept, resolve";
}</code></pre>




    </div>



    <!-- JMS --------------------------------------->

    <h3 id="jms">La communication par JMS<button type="submit" onclick="affichageConditionnel(this,'jms_cache');"> + </button></h3>

    <div id="jms_cache" style="display:none;">

        <div class="pcle"><strong>message</strong> : ensemble de données groupées pour être envoyées et reçues en même temps.</br>
            <strong>serveur d'application :</strong> infrastructure offrant un contexte d'exécution pour des composants applicatifs.</br>
    <strong>JNDI Java Naming and Directory Interface</strong> : il s'agit d'une API Java de connexion à des annuaires, permettant d'accéder à différents services, d'organiser et de rechercher des informations par nommage. JNDI fait partie de Java EE, il est trés utilisé dans les serveurs d'application et nécessite le package naming</div>

    <p>JMS Java Message Service est une API spécialisée dans la création, l'envoi et la lecture de messages. JMS s'apparente donc à un service de messagerie permettant d'envoyer des messages d'une application à une autre sur un poste distant. Les particularités de JMS sont les suivantes :</p>
        <ul>
            <li>la communication est asynchrone, un message arrivera au client sans qu'il n'ait fait de requête</li>
            <li>JMS est fiable, car elle s'assure que le message est bien délivré</li>
        </ul>

        <pre><code class="language-javascript">import java.util.*;
import javax.naming.*;
import javax.jms.*;</code></pre>

        <h4>Fonctionnement de JMS</h4>

        <p>Les messages sont envoyés sur un objet intermédiaire MOM Message Oriented Middleware de type JMSConnectionFactory, et le récepteur doit venir les chercher. Des bus gèrent les transports de messages vers les objets intermédiaires. De ce fait, il est inutile d'établir une connexion entre un émetteur et un récepteur. Par ailleurs, le fournisseur joue le rôle de plateforme de messagerie, comme par exemple Apache ActiveMQ</p>

        <p>JMS contient les classes suivantes :</p>
        <ul>
            <li>Serveur (Publisher ou Sender créé des messages)</li>
            <li>Client (Subscriber ou Receiver lit les messages)</li>
            <li>ObjetEchange</li>
        </ul>

        <img src="jms.png">

        <p>Ce mode de communication indirect permet de mettre en place des services avancés :</p>
    <ul>
        <li>transaction : envoi et réception groupés</li>
        <li>persistance : retransmission des messages en cas de panne</li>
        <li>multicast : communication de groupe</li>
        <li>log : trace des échanges</li>
        <li>gestion des droits d'accès</li>
    </ul>

        <h4>Queue et Topic</h4>

        <p>JMS repose sur deux modes de communication principaux, la communication point-à-point et la communication événementielle.</p>
        <p> Dans la communication point-à-point, l'objet intermédiaire est une file d'attente (queue). Plusieurs senders peuvent envoyer sur la même file d'attente mais un seul receiver peut voir le message. On parle de communication N à 1. La communication est asynchrone et mémorisée. C'est le cas par exemple lorsqu'on utilise une imprimante en mode connecté, ou encore lorsqu'on utilise une boîte mail.</p>
        <p> Dans la communication événementielle, l'objet intermédiaire est un sujet (topic). Les publishers envoient leurs messages sur un topic. Les subscribers s'inscrivent au topic pour recevoir les messages publiés sur ce topic. Plusieurs publishers peuvent envoyer des messages sur le même topic et plusieurs subscribers peuvent consulter les messages du topic. C'est le cas par exemple lors d'un fil de discussion dans un tchat.</p>

        <p>Pour l'envoi de messages : <em>publisher.publish(mess)</em> pour Topic, <em>sender.send(mess)</em> pour Queue</p>
        <p>Pour la réception de messages : <em>subscriber.receive()</em> pour Topic, <em>receiver.receive()</em> pour Queue</p>

    <h4>Exemple d'une communication Topic avec JMS 1.1 :</h4>

        <p>Dans cet exemple le serveur envoie une chaîne de caractères à un client.</p>

        <p>Partie commune au serveur et au client dans un bloc try-catch :</p>

        <pre><code class="language-javascript">// creation du contexte
InitialContext ctx = new InitialContext();
// creation et acces au topic
Topic topic = (Topic) ctx.lookup("MyTopic");
// connexion au provider, creation de l'objet intermediaire
TopicConnectionFactory factory = (TopicConnectionFactory) ctx.lookup("MyConnectionFactory");
// connexion au bus
TopicConnection conn = factory.createTopicConnection();
// creation de session
// false pour spécifier que les messages reçus seront traités en accord
// avec le second paramètre Session.AUTO_ACKNOWLEDGE
TopicSession sess = conn.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);</code></pre>

        <p><em>Côté serveur :</em></p>

<pre><code class="language-javascript">public class Server {

    public static void main(String[] args) {
		try {
			// Le detail des proprietes (url, port, ...) se trouve dans jndi.properties.
            // La creation de props n'est nécessaire que côté serveur
	    	Properties props = new Properties();
            // partie commune

		    // creation d'un objet emetteur
	   		TopicPublisher pbr = sess.createPublisher(topic);
	    	pbr.setDeliveryMode(DeliveryMode.NON_PERSISTENT);

			// publication d'un message "hello world"
            conn.start();
	    	TextMessage mess = sess.createTextMessage("hello world");
	    	// possibilité de changer ultérieurement avec message.setText("hello world");
	    	pbr.publish(mess);

	    	// fermeture de connexion
	    	conn.close();
		} catch (Exception e) {
	    	e.printStackTrace();
		}
    }
}</code></pre>

    <p><em>Côté client :</em></p>

<pre><code class="language-javascript">public class Client {

    public static void main(String[] args) {
		try {
            // partie commune

	    	// creation d'un objet destinataire
	    	TopicSubscriber scr = sess.createSubscriber(topic);

		    // lecture d'un message, receive est une fonction bloquante
		    conn.start();
	    	TextMessage mess = (TextMessage) scr.receive();
	    	System.out.println("message lu : " + mess.getText());

		    conn.close();
		} catch( Exception e ) {
	    	e.printStackTrace();
		}
    }
}</code></pre>

    <h4>Exemple d'une communication Queue avec JMS 1.1 :</h4>

      <p>Dans cet exemple un client envoie une chaîne de caractères au serveur.</p>

        <p>Partie commune au serveur et au client dans un bloc try-catch :</p>

        <pre><code class="language-javascript">InitialContext ctx = new InitialContext();
// creation et acces a la file d'attente
Queue queue = (Queue) ctx.lookup("MyQueue");
QueueConnectionFactory factory = (QueueConnectionFactory) ctx.lookup("MyConnectionFactory");
QueueConnection conn = factory.createQueueConnection();
QueueSession sess = conn.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);</code></pre>

        <p><em>Côté serveur :</em></p>

        <pre><code class="language-javascript">public class Serveur {

    public static void main(String[] args) {
		try {
	    	// partie commune

	    	QueueReceiver rcv = sess.createReceiver(queue);

	    	conn.start();
	    	TextMessage mess = (TextMessage) rcv.receive();
		    System.out.println("message reçu: " + mess.getText());

	    	conn.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
    }
}</code></pre>

<p><em>Côté client</em></p>

    <pre><code class="language-javascript">public class Client {

    public static void main(String[] args) {
		try {
	    	// partie commune

	    	QueueSender sdr = sess.createSender(queue);
	    	sdr.setDeliveryMode(DeliveryMode.NON_PERSISTENT);

            conn.start();
	    	TextMessage mess = sess.createTextMessage("hello world");
	   		sdr.send(mess);

	   		conn.close();
		} catch( Exception e ) {
	    	e.printStackTrace();
		}
    }
}</code></pre>

    <h4>Exemple d'un échange de mails Queue avec JMS 1.1 :</h4>

        <p>Dans cet exemple, un serveur transmet un mail sous forme d'objet et reçoit une chaîne de caractères en réponse d'un client.</p>

<pre><code class="language-javascript">InitialContext ctx = new InitialContext();
Queue queue = (Queue) ctx.lookup("MyQueue");
QueueConnectionFactory factory = (QueueConnectionFactory) ctx.lookup("MyConnectionFactory");
QueueConnection conn = factory.createQueueConnection();
QueueSession sess = conn.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);</code></pre>

    <p><em>Côté serveur</em></p>

        <img src="JMSObjet.png">

    <pre><code class="language-javascript">public class Serveur {

	public static void main(String[] args) {
		try {
	    	// partie commune

	    	QueueSender sdr = sess.createSender(queue);
	    	sdr.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
	    	QueueReceiver rcv = sess.createReceiver(queue);

	    	// envoi d'un mail
	    	GregorianCalendar date = new GregorianCalendar(2016,11,24);
	    	ObjetTransmis letter = new ObjetTransmis("moi", date, "Hello");
	    	ObjectMessage message = sess.createObjectMessage(letter);
	    	conn.start();
	    	sdr.send(message);

	    	// attente que le destinataire reçoive le message
	    	Thread.sleep( 5000 );

	    	// reception d'un message reponse
	    	TextMessage reponse = (TextMessage) rcv.receive();
	    	System.out.println("received: " + reponse.getText());

	    	conn.close();
		} catch ( Exception e ) {
	    	e.printStackTrace();
		}
    }
}</code></pre>

    <p><em>Côté client</em></p>

    <pre><code class="language-javascript">public class Client {

    public static void main(String[] args) {
		try {
	    	// partie commune

	    	QueueReceiver consumer = sess.createReceiver(queue);
            QueueSender producer = sess.createSender(queue);
	    	producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);

	    	// lecture d'un mail
	    	conn.start();
	    	ObjectMessage message = (ObjectMessage) consumer.receive();
	    	ObjetTransmis letter = (ObjetTransmis) message.getObject();
	    	System.out.print("mail reçu : "+ letter.toString());

	    	// envoi d'un message reponse
	    	TextMessage reponse = sess.createTextMessage("Merci");
	    	producer.send(reponse);

	    	conn.close();
		} catch (Exception e) {
	    	e.printStackTrace();
		}
    }
}</code></pre>

    <p><em>et la classe ObjetEchange :</em></p>

        <p>La classe ObjetEchange doit être présente à la fois côté serveur et côté client. Comme l'objet doit être transmis, la classe ObjetEchange implémente l'interface Serialitable.</p>
    <pre><code class="language-javascript">public class ObjetEchange implements Serializable {
    String emetteur;
    GregorianCalendar date;
    String texte;

    public ObjetEchange(String emetteur, GregorianCalendar date, String texte) {
	    this.emetteur = emetteur;
	    this.date = date;
	    this.texte = texte;
    }

    @Override
    public String toString() {
        System.out.println("message de : " + emetteur + ", émis le : " + date.getTime() + ", contenu : " + texte );
    }
}</code></pre>

    </div>



    <!-- Les services Web -------------------------------------------------->

    <h3 id="servicesweb">Les services Web<button type="submit" onclick="affichageConditionnel(this,'servicesweb_cache');"> + </button></h3>

    <div id="servicesweb_cache" style="display:none;">

    <div class="pcle"><strong>sérialisation</strong> : codage d'une information sous fome de suite de données atomiques.</br>
    <strong>parser un fichier</strong> : analyser un fichier afin d'en retirer les informations utiles.</br>
        <strong>serveur d'applications</strong> : logiciel d'infrastructure offrant un contexte d'exécution pour des applications Web et non pas de simples procédures ou scripts.</br>
        <strong>verbe HTTP</strong> : méthodes HTTP GET, POST, PUT, DELETE, ...</br>
        <strong>POJO Plain Old Java Object </strong> : objet Java lié à aucune restriction autre que celles de la spécification du langage Java. Un POJO n'étend pas de classe pré-définie, n'implémente pas d'interface et ne contient pas d'annotation pré-spécifiée @...</br>
        <strong>Servlet </strong> : classe Java qui permet de créer dynamiquement des données au sein d'un serveur HTTP. Ces données sont présentées au format HTML ou XML.</div>

    <p>Les services Web sont un ensemble de technologies permettant l'invocation de méthodes distantes. La communication et l'échange de données sont basés sur les standards Web HTTP et XML. SOAP et REST sont 2 solutions permettant à un client d'accéder aux services Web.</p>

    <p>Les principaux avantages des services Web sont les suivants :</p>
    <ul>
        <li>portabilité entre différents langages, différents systèmes d'exploitation</li>
        <li>utilisation de standards et protocoles ouverts</li>
        <li>utilisation des formats XNL dans les échanges de données</li>
        <li>flexibilité, extensibilité</li>
    </ul>

    <h4>SOAP Simple Object Access Protocol</h4>

    <p>SOAP est un protocole de RPC Remote Procedure Call orienté objet et basé sur l'échange de données structurées en XML. SOAP permet l'appel de méthodes distantes dans un environnement distribué.</p>
    <p>Un message SOAP est un document XML composé d'une <em>envelope</em> avec un <em>header</em> et le <em>body</em>, corps du message. Dans le cas de l'envoi d'une image, on peut utiliser un message SOAP avec attachement en utilisant un message MIME Multimedia Internet Mail Extension.</p>

    <p>L'architecture des services SOAP se base sur les protocoles suivants :</p>
    <ul>
        <li>un protocole de transfert HTTP ou SMTP, les données échangées sont représentées en XML</li>
        <li>un protocole de description des services et méthodes WSDL</li>
        <li>un protocole de localisation des services UDDI, facultatif</li>
    </ul>

    <p>WSDL Web Service Description Langage donne la description au format XML des services Web en précisant les méthodes pouvant être invoquées. Le client a besoin de cette description détaillée des services Web avant de pouvoir les utiliser.</p>

    <p>UDDI Universal Description Discovery and Integration est un annuaire des services publiés par les providers. Une entrée du répertoire UDDI est constituée d'un fichier XML.</p>

    <p><em>Exemple de requête SOAP :</em></p>

    <pre><code class="language-javascript">HTTP/1.1 200 OK
Content-Type: text/xml; charset=utf-8
Content-Length: length

&lt?xml version="1.0" encoding="utf-8"?&gt
&ltsoap:Envelope xmlns:soap="http://www.w3.org/2001/soap/envelope"&gt
&ltsoap:Body&gt
    &ltm:GetPrice xmlns:m="http://www.w3schools.com/prices"&gt
        &ltm:Item&gtApples&lt/m:Item&gt
    &lt/m:GetPrice&gt
&lt/soap:Body&gt
&lt/soap:Envelope&gt</code></pre>

    <p><em>Réponse SOAP :</em></p>

    <pre><code class="language-javascript">HTTP/1.1 200 OK
Content-Type: text/xml; charset=utf-8
Content-Length: length

&lt?xml version="1.0" encoding="utf-8"?&gt
&ltsoap:Envelope xmlns:soap="http://www.w3.org/2001/soap/envelope"&gt
&ltsoap:Body&gt
    &ltm:GetPriceResponse xmlns:m="http://www.w3schools.com/prices"&gt
        &ltm:Price&gt2.59&lt/m:Price&gt
    &lt/m:GetPriceResponse&gt
&lt/soap:Body&gt
&lt/soap:Envelope&gt</code></pre>

    <h4>Développement d'un service Web SOAP avec JAX-WS</h4>

    <p>JAX-WS est intégré dans Java pour développer des services Web.</p>
    <p>Le développement d'un service Web SOAP avec JAX-WS se fait en plusieurs étapes :</p>
    <ul>
        <li>créer une interface publique</li>
        <li>implémenter l'interface</li>
        <li>publier et déployer l'application localement</li>
    </ul>

        <p>Les fichiers côté client sont créés lors de la génération du stub</p>
        <p> le fichier main du client : voir cours</p>
    <pre><code class="language-javascript">// interface publique
import javax.jws.*;
import javax.jws.soap.*;

@WebService
@SOAPBinding(style = Style.RCP)
public interface HelloWorld {
    String getHelloWorldAsString(String nom);
}</code></pre>

    <pre><code class="language-javascript">// implémentation de l'interface
        // voici mon contrat WSDL
import javax.jws.*;

@WebService(endpointInterface = "ws.HelloWorld")
public class HelloWorldImpl implements HelloWorld {

    @Overrride
    public String getHelloWorldAsString(String nom) {
        return "Hello World JAX-WS "+nom;
    }
}</code></pre>

<pre><code class="language-javascript">// publication de l'application et déploiement
    // j'ai exécuté la requête et je retourne le résultat
import javax.xml.ws.*;

public class HelleWorldPublisher {
    public static void main(String[] args) {
        Endpoint.publish("http://localhost:9999/ws/hello", new HelloWorldIml());
    }
}</code></pre>

    <h4>REST Representational State Transfer</h4>

    <p>REST se base sur le protocole HTTP pour transférer les ressources qui sont identifiées par des URI Uniform Resource Identifier. Les requêtes du protocole HTTP sont composées d'une ligne de commande, d'une entête et d'un corps de message. Le format de stockage des données est principalement JSON JavaScript Object Notation, mais également XML.</p>

        <p>Les URI regroupent 2 sous-types d'identificateurs, les URN Uniform Resource Name et les URL Uniform Resource Locator. Les URL comprennent les chemins d'accès aux ressources accessibles. Par exemple http://domaine/chemin et mailto: adresseMail@gmail.com sont des URL. Les URN permettent de définir une identification unique et persistance pour une ressource. Par exemple l'adresse MAC d'une ordinateur, la référence ISBN:0-233-988897-2 d'un livre sont des URN.</p>

    <p>Les principales caractéristiques des services REST sont les suivantes :</p>
    <ul>
        <li>identification des ressources via des URI</li>
        <li>manipulation des ressources avec uniquement 4 opérations CRUD : Create avec la méthode POST, Retrieve avec la méthode GET, Update avec la méthode PUT et Delete avec la méthode DELETE</li>
        <li>les ressources sont séparées de leur représentation HTML, XML, PDF, JPEG, JSON</li>
    </ul>

    <p>Plusieurs frameworks aident au développement des Web services REST en prenant en charge l'analyse et le traitement des requêtes côté serveur et des réponses côté client, comme par exemple Spring ou Jersey qui est intégré dans Java EE. L'interface Java pour implémenter des services Web REST s'appelle JAX-RS. Il s'agit d'un Servlet basé sur des POJO et contenant des annotations @Path, @GET, @Produces qui complètent l'objet pour en faire un objet invocable à distance à travers une méthode HTTP et accessible par un URI. L'annotation @Path permet d'indiquer que l'objet doit être exposé comme un service répondant à des requêtes REST.</p>

    <p>Les services Web REST sont généralement déployés dans les serveurs d'application comme Tomcat et JBoss.</p>

        <p>Le service Web de type REST est plus souple que le type SOAP qui est maintenant désué. REST est une API dans lequel on ne trouve pas de contrat comme pour RMI ou SOAP.</p>

        <p><em>Exemple de format JSON :</em></p>

<pre><code class="language-javascript">{
    'prenom': 'Stephane',
    'nom': 'Dupret',
    'age': 35,
    'adresse': {
        'rue': '12 bd de la libération',
        'ville': 'Marseille',
        'codePostal': '13013'
    },
    'numerosTph': [
        {
        'type': 'domicile',
        'nmr': '01234567889'
        },
        {
        'type': 'bureau',
        'nmr': '0198765432'
        }
    ]
}</code></pre>

    <p>Exemple d'utilisation de JSON avec le package Gson</p>

    <pre><code class="language-javascript">import com.google.gson.Gson
Gson gson = new Gson();
MyInData mid = new MyInData(45, 0.1, "hello");
String toJsonString = gson.toJson(mid);

MyInData fromJsonString = gson.froJson(jsonString, MyInData.class);</code></pre>

<h4>Exemple de communication avec un service REST :</h4>

        <p>Dans l'exemple ci-dessous, un serveur gère un service de contacts. REST ne nécessite pas de programmation côté client mais fonctionne avec un navigateur, dans lequel il convient de fournir les adresses correctes pour satisfaire les différentes requêtes. Le code au niveau du Servlet JAX-RS est le suivant :</p>

        <img src="rest.png">

<pre><code class="language-javascript">import javax.xml.bind.annotation.*;

// il faut serialiser ce pojo en XML en utilisant Jackson
@XmlRootElement
public class Contact {
    public int id;
    public String name;
    public String email;

    public Contact(int id, String name, String email) {
        this.id = id;
        this.name = name;
        this.email = email;
    }

    @Override
    public String toString() {
        return "id :" + id + " name : " + name + ", email : " + email;
    }
}</code></pre>

        <p><em>La classe ContactBookResource</em> permet de gérer les requêtes avec la liste des contacts.</p>

<pre><code class="language-javascript">import java.util.*;
import javax.ws.rs.*;
import javax.ws.rs.core.*;
import javax.ws.rs.core.Response.*;

@Path("/mescontacts") // donné comme référence dans l'uri, ne correspond pas forcément au nom du dossier courant
public class ContactBookResource {
    static ContactDAO dao = new ContactDAO(); // DAO pour Data Access Object

    @GET
    // produit des fichiers JSON dans le cas général d'une requête, peut également produire du XML
    @Produces(MediaType.APPLICATION_JSON) // {  , MediaType.APPLICATION_XML})
    public ArrayList&ltContact&gt  getListeContact() {
        return dao.getListeContact();
    }

    @GET
    // Dans le cas particulier d'une requete avec id, on obtient les informations du contact a partir de son id
    @Path("{id}")
    @Produces(MediaType.APPLICATION_JSON)
    public Response getContact(@PathParam("id") int id) {
        Contact contact = dao.getContact(id);
        if (c == null) {
            return Response.status(Response.Status.NOT_FOUND).build();
        } else {
            return Response.status(Response.Status.OK).entity(contact).build();
        }
    }

    @POST
    // on ajoute un contact sous forme JSON
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    public Response setContact(Contact contact) {
        Contact originalContact = dao.getContact(contact.id);
        if (originalContact != null) {
            return Response.status(Response.Status.CONFLICT).build();
        } else {
            dao.addContact(contact);
            return Response.status(Response.Status.OK).entity(contact).build();
        }
    }

    @PUT
    // le contact est modifie a partir de son id
    @Path("{id}")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    public Response updateContact(@PathParam("id") int ident, Contact contact) {
        Contact originalContact = dao.getContact(ident);

        if (originalContact == null) {
            return Response.status(Response.Status.NOT_FOUND).build();
        } else {
            contact.id = ident;
            dao.updateContact(ident, contact);
            return Response.status(Status.OK).entity(contact).build();
        }
    }

    @DELETE
    // le contact est efface par rapport a son id
    @Path("{id}")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    public Response deleteContact(@PathParam("id") int id) {
        Contact originalContact = dao.getContact(id);

        if (originalContact == null) {
            return Response.status(Response.Status.NOT_FOUND).build();
        } else {
            dao.deleteContact(id);
            return Response.status(Status.OK).entity(originalContact).build();
        }
    }
}</code></pre>

        <p>Pour des raisons de commodité la liste des contacts est structurées en dictionnaire. Une structure de type liste n'aurait pas permis de conserver l'identité d'un contact à la suite de changements. En effet, suite à des changements, les éléments d'une liste sont bougés et leur index varie. Ce n'est pas le cas pour un dictionnaire auquel on rajoute un champ index. La classe ContactDAO permet de gérer cette liste de contacts.</p>

<pre><code class="language-javascript">import java.util.*;

public class ContactDAO {
    public HashMap&ltInteger, Contact&gt dico = new HashMap&ltInteger, Contact&gt();

    public ContactDAO() {
        Contact c1 = new Contact(0, "user1", "user1@domaine.org");
        Contact c2 = new Contact(1, "user2", "user2@domaine.org");

        dico.clear();
        dico.put(c1.id, c1);
        dico.put(c2.id, c2);
    }

    public ArrayList&ltContact&gt getListeContact() {
        return new ArrayList&ltContact&gt(dico.values());
    }

    public Contact getContact(int id) {
        return dico.get(id);
    }

    public void addContact(Contact contact) {
        dico.put(contact.id, contact);
    }

    public void updateContact(int id, Contact contact) {
        dico.put(id, contact);
    }

    public void deleteContact(int id) {
        dico.remove(id);
    }
}</code></pre>

        <p>La configuration du serveur se fait grâce à la classe <em>ServletHolder</em>. La classe <em>ServletContextHandler</em> permet la gestion des principales fonctionnalités.</p>

<pre><code class="language-javascript">import java.util.logging.*;
import org.eclipse.jetty.server.*;
import org.eclipse.jetty.servlet.*;
import org.glassfish.jersey.servlet.*;

public class JettyServer {
    public static void main(String[] args) {
        Server srv = new Server(8080);

        // gestionnaire d'événements sur le serveur et des principales fonctionnalités
        ServletContextHandler ctx = new ServletContextHandler(ServletContextHandler.NO_SESSIONS);
        ctx.setContextPath("/"); // racine du serveur
        srv.setHandler(ctx);

        // configuration du serveur
        ServletHolder hld = ctx.addServlet(ServletContainer.class, "/rest/*");
        hld.setInitOrder(1);
        // chemin pour import de packages
        hld.setInitParameter("jersey.config.srv.provider.packages", "fr.rest");

        try {
            srv.start();
            System.out.println("Services deployed on URL = http://localhost:8080/rest/mescontacts");
            srv.join(); // gestion de threads sur Jetty
        } catch (Exception ex) {
            e.getStackTrace();
        } finally {
            srv.destroy();
        }
    }
}</code></pre>


    <p><em>Les principaux codes statut de réponse : </em></p>
        <ul>
            <li>200 OK : tout s'est bien passé</li>
            <li>201 Created : la création de la ressource s'est bien passée</li>
            <li>204 No content : tout s'est bien passé mais le contenu de la ressource n'est pas renvoyé en réponse</li>
            <li>304 Not modified : le contenu n'a pas été modifié</li>
            <li>400 Bad request : la demande n'a pas pu être traitée correctement</li>
            <li>401 Unauthorized : l'authentification a échoué</li>
            <li>404 Not found : la ressource n'existe pas</li>
            <li>405 Method not allowed : la méthode HTTP utilisée n'est pas traitable par l'API</li>
            <li>406 Not acceptable : l'API n'est pas capable de fournir le format demandé</li>
            <li>500 Server error : le serveur a rencontré un problème</li>
        </ul>

         </div>

</section>

<footer>
    Stephane Robin
</footer>

</body>
</html>

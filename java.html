<!DOCTYPE HTML>
<html>
<head>
  <title> Memento </title>
  <link rel="stylesheet" href="style.css">
  <meta charset="utf-8">
</head>

<body>

<header>
  <div class="heroImage">
    <div class="heroTexte">
      <h2> Java </h2>
    </div>
  </div>
</header>

<div id="bandeau">
  <div id="titre"> <h1> Memento </h1> </div>
  <nav>
    <div class="element"> <a href="index.html">HTML</a> </div>
    <div class="element"> <a href="css.html">CSS</a> </div>
    <div class="element"> <a href="javascript.html">JAVASCRIPT</a> </div>
    <div class="element"> <a href="python.html">PYTHON</a> </div>
    <div class="element"> <a href="java.html">JAVA</a> </div>
    <div class="element"> <a href="c.html">C</a> </div>
    <div class="element"> <a href="git.html">GIT</a> </div>
  </nav>
</div>

<section id="principal">

    <div class="bloc">

        <div class="gauche">
            <p>Java est un langage orienté objet qui utilise un compilateur (javac) puis une machine virtuelle
                compabible toutes plateformes JVM Java Virtual Machine pour interpréter le Byte code. De ce fait,
                c'est un langage offrant une grande portabilité.
                C’est un langage à la fois compilé et interprété. Il est donc plus rapide que Python (interprété) mais
                plus lent que C++ (compilé).</p>
        </div>

        <div class="droite">
            <img src="java.png" width="60" height="100">
        </div>

    </div>

<hr>

<!-- ===== LA PROGRAMMATION RESEAU ===== -->

<h3>La programmation réseau</h3>

<h4>Rappels sur les réseaux</h4>

<p>La communication réseau est initialement définie par le modèle OSI en 7 couches. Toutefois, la plupart des logiciels reposent sur le modèle TCP/IP en 4 couches : réseau, Internet, transport, application. C'est dans cette dernière couche du modèle TCP/IP que se positionne Java.</p>
<p>Notons que par défaut les principaux protocoles de transfert utilisent les ports suivants :</p>
<ul>
    <li>http : port 80</li>
    <li>ftp : port 20 ou 21</li>
    <li>smtp : port 25</li>
</ul>

<h4>La classe InetAddress</h4>

<p>Pour manipuler des adresses IP, on utilise la classe InetAddress. On peut par exemple créer un objet adresse de la façon suivante :</p>
<pre>import java.net.InetAddress;
import java.net.UnknownHostException;</pre>
<p></p>

<table>
    <tr><th>Objectif</th><th>Code</th></tr>
    <tr><td>nom de l'hôte (client)</td><td>adresse.getHostName()</td></tr>
    <tr><td>adresse IP</td><td>adresse.getHostAddress()</td></tr>
    <tr><td>teste si l'adresse est de type boucle locale</td><td>adresse.isLoopbackAddress()</td></tr>
</table>

<p>Ainsi pour récupérer l'adresse IP de son poste et son adresse de boucle locale :</p>
<pre>try {
	InetAddress adresse = InetAddress.getLocalHost();
		           
	System.out.println("L'adresse IP de " + adresse.getHostName() + " est : "
        + adresse.getHostAddress()); 
		         
	adresse = InetAddress.getByName("localhost");
		        
	System.out.println("L'adresse IP de " + adresse.getHostName() + " est : "
        + adresse.getHostAddress()); 
} catch (UnknownHostException e) {
        e.printStackTrace();
}</pre>

<p>De même pour récupérer l'adresse IP d'un site Internet à partir de son url :</p>
<pre>try {
	InetAddress adresse = InetAddress.getByName("meteocentrale.ch");
	System.out.println("L'adresse IP de " + adresse.getHostName() + " est : "
        + adresse.getHostAddress());
	         
	//Certains sites Internet peuvent avoir plusieurs adresses IP
	InetAddress[] addresses = InetAddress.getAllByName("amazon.fr");
	System.out.println("\nToutes les adresses IP de amazon.fr : ");
	for(InetAddress ad : addresses)
	    System.out.println(" - " + ad.getHostAddress()); 
} catch (UnknownHostException e) {
	e.printStackTrace();
}</pre>

<h4>La classe URL</h4>

<p>On peut également utiliser la classe URL :</p>
<pre>import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;</pre>

<p></p>
<table>
    <tr><th>Objectif</th><th>Code</th></tr>
    <tr><td>nom du site</td><td>url.getAuthority()</td></tr>
    <tr><td>port par défaut</td><td>url.getDefaultPort()</td></tr>
    <tr><td>nom de l'hébergeur</td><td>url.getHost()</td></tr>
    <tr><td>numéro de port spécifié</td><td>url.getPort()</td></tr>
    <tr><td>protocole</td><td>url.getProtocol()</td></tr>
</table>

<p>Ainsi pour récupérer les données d'un site Internet :</p>
<pre>try {
         
    URL url = new URL("http://www.meteofrance.fr");
         
    System.out.println("Authority : " + url.getAuthority());
    System.out.println("Default port : " + url.getDefaultPort());
    System.out.println("Host : " + url.getHost());
    System.out.println("Port : " + url.getPort());
    System.out.println("Protocol : " + url.getProtocol());
         
} catch (MalformedURLException e) {
    e.printStackTrace();
}</pre>

<p>Dans cet exemple le port -1 signifie que le port n'a pas été spécifié dans l'URL.</p>

<p>Pour vérifier qu'une saisie utilisateur correspond à une url, on peut par exemple utiliser la condition :</p>
<pre>if(host.matches("[a-zA-Z\\.]+"))</pre>

<hr>

<!-- ===== LES SOCKETS ===== -->

<h3>Les sockets</h3>

    <p>Les sockets sont des API permettant de gérer les communications entre programmes. La communication de plusieurs machines sur un réseau nécessite donc la connaissance d'adresses, de ports, de protocoles et l'utilisation de sockets. Les sockets permettent de se connecter à une machine distante, de recevoir et envoyer des données, de fermer une connexion établie, d'attendre une connexion de l'extérieur, d'écouter les communications entrantes.</p>
<p>Une même socket sert aussi bien à envoyer qu'à recevoir des communications.</p>

    <p>Une socket est identifiée de manière unique par l'adresse IP de la machine suivi du numéro de port utilisé, ce dernier étant compris entre 1024 et 65536.</p>

    <p>Java fait la différence entre deux types de sockets :</p>
<ul>
    <li>socket côté client permettant de se connecter à une machine distante afin de communiquer avec elle</li>
    <li>socket côté serveur, qui une fois connecté attend qu'un client vienne se connecter afin de communiquer avec lui</li>
</ul>

    <p>L'utilisation de socket côté client se déroule ainsi :</p>
    <ul>
        <li>demande de connexion avec le serveur</li>
        <li>connexion de la socket avec le service côté serveur (ftp, http)</li>
        <li>envoi des messages</li>
        <li>fermeture de la connexion</li>
    </ul>

    <p>L'utilisation de socket côté serveur se déroule ainsi :</p>
    <ul>
        <li>attente de demande de connexion venant d'un client</li>
        <li>ouverture de la connexion</li>
        <li>traitement des messages</li>
        <li>fermeture de la connexion</li>
    </ul>

    <p>Le serveur utilise une socket spécifique pour recevoir des demandes de connexion, puis crée une socket de communication pour échanger avec le client.</p>

    <p>Les sockets travaillent en full-duplex, i.e. le client et le serveur peuvent envoyer et recevoir des signaux simultanément. Il n'y a donc aucune attente. Il existe deux modes de connexion :</p>
    <ul>
        <li>le mode connecté où deux sockets établissent une communication durable qui permet d'éviter de transmettre l'identité de la socket destinatrice à chaque envoi. Dans ce cas, un des programmes prend le rôle du serveur et l'autre le rôle du client. Le serveur est donc vu comme un programme rendant des services aux clients</li>
        <li>le mode non connecté où le destinataire de la socket est précisé à chaque envoi.</li>
    </ul>

    <h4>Le mode connecté</h4>

    <pre>import java.io.IOException;
import java.net.Socket;
import java.net.UnknownHostException;</pre>

    <p>Dans le mode connecté, les serveurs utilisent la classe ServerSocket et les clients utilisent la classe Socket.</p>
    <p>La création de sockets côté serveur se fait grâce à l'instruction :</p>
    <pre>public ServerSocket(int port) throws IOException
public ServerSocket(int port, int backlog) throws IOException
public ServerSocket(int port, int backlog, InetAddress adresse) throws IOException</pre>

    <p>Le serveur attend ensuite les demandes de connexion en utilisant une fonction bloquante i.e. qu'elle ne libère pas le programme tant qu'elle n'a pas reçu de demande de connexion :</p>
    <pre>public Socket accept() throws IOException</pre>

    <p>La création de sockets côté client se fait grâce à l'instruction :</p>
    <pre>public Socket(String host, int port) throws UnknownHostEception, IOException
public Socket(InetAddress adresse, int port) throws IOException
public Socket(String host, int port, InetAddress adresseLocale, int localPort)
        throws UnknownHostException, IOException
public Socket(InetAddress adresse, int port, InetAddress adresseLocale, int localPort)
        throws IOException</pre>

    <p>Les méthodes de la classe Socket permettant d'obtenir des informations sur la connexion :</p>

    <table>
        <tr><th>Instruction</th><th>Résultat</th></tr>
        <tr><td>adresse.getInetAddress()</td><td>fournit l'adresse IP distante</td></tr>
        <tr><td>adresse.getLocalAddress()</td><td>fournit l'adresse IP locale</td></tr>
        <tr><td>adresse.getPort()</td><td>fournit le nmr de port distant</td></tr>
        <tr><td>adresse.getLocalPort()</td><td>fournit le nmr de port local</td></tr>
    </table>

    <h4>Le mode non connecté</h4>

    <p>Dans le mode non connecté, la communication utilise la classe DatagramSocket.</p>

    <h4>Tester les ports disponibles du client</h4>

    <p>Pour tester les 1024 premiers ports du client à l'aide de cette classe :</p>
    <pre>for(int i = 1; i <= 1024; i++){
    try {
        Socket soc = new Socket("127.0.0.1", i);
        System.out.println("ports autorisés sur la machine : " + i);
    } catch (UnknownHostException e) {
        e.printStackTrace();
    }catch (IOException e) {
        System.out.println("ioexception");
        // le port n'est pas ouvert ou n'est pas autorisé
    }
}</pre>

<p>Pour spécifier sur quel port du client le serveur devra répondre :</p>
    <pre>try {
    //Nous spécifions que la réponse devra se faire par ce chemin
    InetAddress lo = InetAddress.getByName("188.165.53.185");

    //Le fait de mettre 0 dans le numéro de port de réponse
    //informe que n'importe quel numéro est accepté
    Socket soc = new Socket("www.adret-attitude.ch", 80, lo, 0);
}catch (UnknownHostException e) {
    e.printStackTrace();
} catch (Exception e) {
    e.printStackTrace();
}</pre>

    <h4>Fermer une socket en fin de communication</h4>

    <p>La machine virtuelle Java ferme les sockets non utilisés à la fin de l'exécution du programme. Toutefois, le nombre de sockets ouvertes par un programme est limité, ce qui conduit à des erreurs quand cette limite est atteinte. La méthode close() permet de fermer la connexion.</p>

    <p>Pour fermer une socket en fin de communication :</p>
    <pre>Socket sock = null;
      try {
         //On se connecte au site
         sock = new Socket("www.adret-attitude.com", 80);

      } catch (UnknownHostException e) {
         e.printStackTrace();
      } catch (IOException e) {
         e.printStackTrace();
      }
      finally{
         if(sock != null){
            try {
               sock.close();
            } catch (IOException e) {
               e.printStackTrace();
               sock = null;
            }
         }
}</pre>

    <h4>Communiquer avec un serveur</h4>

    <p>On utilise l'objet HttpURLConnection.</p>
    <p>Les flux BufferedInputStrean et BufferedOutputStrean permettent de gagner en performance plutôt que de travailler directement avec les sockets.</p>

    <hr>

    <!-- LES STREAMS -->

    <h3>Les streams</h3>



<hr>

    <!-- ===== LES PROXYS ===== -->

    <h3>Les proxys</h3>

    <p>Un proxy constitue une autre façon de se connecter à un serveur. Le proxy est un intermédiaire faisant le lien entre le client et le serveur.</p>
<pre>import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.Proxy;
import java.net.Socket;
import java.net.SocketAddress;

//On crée une adresse correspondant à notre proxy
SocketAddress proxyAddress = new InetSocketAddress("10.10.10.10", 8080);

//On instancie la classe Proxy avec le type souhaité
Proxy proxy = new Proxy(Proxy.Type.SOCKS, proxyAddress);

//On crée notre socket utilisant le proxy
Socket s = new Socket(proxy);

//On crée l'adresse que l'on souhaite atteindre via le proxy
SocketAddress remote = new InetSocketAddress("www.adret-attitude.ch", 80);
try {
    //On connecte le tout !
    s.connect(remote);
} catch (IOException e) {
    e.printStackTrace();
}</pre>

    <p></p>

    <table>
        <tr><th>Objectif</th><th>Code</th></tr>
        <tr><td>port côté serveur</td><td>s.getPort()</td></tr>
        <tr><td>port côté client</td><td>s.getLocalPort()</td></tr>
        <tr><td>nom hôte distant</td><td>s.getInetAddress().getHostName()</td></tr>
        <tr><td>adresse hôte distant</td><td>s.getInetAddress().getHostAddress()</td></tr>
        <tr><td>adresse socket hôte distant</td><td>s.getRemoteSocketAddress()</td></tr>
    </table>

    <pre>try {
    Socket s = new Socket("www.adret-attitude.ch", 80);
    System.out.println("Port de communication côté serveur : " + s.getPort());
    System.out.println("Port de communication côté client : " + s.getLocalPort());
    System.out.println("Nom de l'hôte distant : " + s.getInetAddress().getHostName());
    System.out.println("Adresse de l'hôte distant : " + s.getInetAddress().getHostAddress());
    System.out.println("Adresse socket de l'hôte distant : " + s.getRemoteSocketAddress());
} catch (UnknownHostException e) {
        e.printStackTrace();
} catch (IOException e) {
        e.printStackTrace();
}</pre>


</section>

<footer>
</footer>

</body>
</html>

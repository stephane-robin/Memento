<!DOCTYPE HTML>
<html>
<head>
  <title> Memento </title>
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="prism.css">
  <meta charset="utf-8">
</head>

<!-- script de gestion des couleurs de code -->
<script defer src="prism.js"></script>

<!-- script de gestion de l'apparition du contenu d'une section -->
<script type="text/javascript">
function affichageConditionnel(bouton, id) {
    var div = document.getElementById(id);
    if(div.style.display=="none") { // si le div est masqué, on l'affiche et on change le contenu du bouton
        div.style.display = "block";
        bouton.innerHTML = "-";
    } else { // s'il est visible, on le masque et on change le contenu du bouton
        div.style.display = "none";
        bouton.innerHTML = "+";
    }
}</script>

<body>

<header>
  <div class="heroImage">
    <div class="heroTexte">
      <h2> Java </h2>
    </div>
  </div>
</header>

<div id="bandeau">
  <div id="titre"> <h1> Memento </h1> </div>
  <nav>
    <div class="element"> <a href="index.html">HTML</a> </div>
    <div class="element"> <a href="css.html">CSS</a> </div>
    <div class="element"> <a href="javascript.html">JAVASCRIPT</a> </div>
    <div class="element"> <a href="python.html">PYTHON</a> </div>
    <div class="element"> <a href="java.html">JAVA</a> </div>
    <div class="element"> <a href="c.html">C</a> </div>
    <div class="element"> <a href="git.html">GIT</a> </div>
  </nav>
</div>

<section id="principal">

    <div class="bloc">

        <div class="gauche">
            <p>Java est un langage orienté objet qui utilise un compilateur (javac) puis une machine virtuelle
                compatible toutes plateformes JVM Java Virtual Machine pour interpréter le Byte code. De ce fait,
                c'est un langage offrant une grande portabilité.
                C’est un langage à la fois compilé et interprété. Il est donc plus rapide que Python (interprété) mais
                plus lent que C++ (compilé). java -version en ligne de commande permet de vérifier que java est installé.</p>
        </div>

        <div class="droite">
            <img src="java.png" width="60" height="100">
        </div>

    </div>

    <p style="font-weight:bold"> Table des matières :</p>
        <ul>
            <li> <a href="#javaterminal">Exécuter Java au Terminal</a></li>
            <li> <a href="#dates">Les dates</a></li>
            <li> <a href="#programmationreseau">La programmation réseau</a> </li>
            <li> <a href="#programmationclientserveur">Programmation client-serveur</a> </li>
            <li> <a href="#proxys">Les proxys</a> </li>
            <li> <a href="#mecanismermi">Le mécanisme RMI</a></li>
            <li> <a href="#jms">JMS</a></li>
            <li> <a href="#servicesweb">Les services Web</a></li>
        </ul>



    <!-- EXECUTER JAVA AU TERMINAL ================================== -->

    <h3 id="javaterminal">Exécuter Java au terminal <button type="submit" onclick="affichageConditionnel(this,'javaterminal_cache');"> + </button></h3>

    <div id="javaterminal_cache" style="display:none;">

    <p>Pour exécuter un programme Java en utilisant le terminal, il faut d'abord se rendre dans le dossier comportant le fichier, puis compiler le programme avec la commande</p> <pre><code class="language-javascript">javac monFichier.java</code></pre> <p>Le fichier se transforme alors en binaire exécutable par la Machine Virtuelle Java : monFichier.class. Pour exécuter ce programme il reste maintenant à utiliser la commande</p> <pre><code class="language-javascript">java monFichier</code></pre>

    </div>


    <!-- LES DATES -------------------------------------------------->

    <h3 id="#dates">Les dates<button type="submit" onclick="affichageConditionnel(this,'dates_cache');"> + </button></h3>

    <div id="dates_cache" style="display:none;">

    <p>L'utilisation de la classe Date est obsolète. Il est préférable d'utiliser la classe GregorianCalendar qui hérite de la classe abstraite Calendar.</p>
    <p>On peut afficher le timestamp du moment sans formattage particulier en utilisant</p>
    <pre><code class="language-javascript">new GregorianCalendar().getTime()</code></pre>

    <p>Pour instancier une date à la date du jour, on utilise</p>
    <pre><code class="language-javascript">GregorianCalendar date = new GregorianCalendar();</code></pre>

    <p>Pour instancier une date à la date du 03/06/2018</p>
    <pre><code class="language-javascript">GregorianCalendar date = new GreogorianCalendar(2018,05,03);</code></pre>
    <p>car les mois sont notés de 0 à 11.</p>

    <p>Les différents éléments de date sont les suivants :</p>
    <pre><code class="language-javascript">date.get(Calendar.YEAR);
date.get(Calendar.MONTH);
date.get(Calendar.DAY_OF_MONTH);
date.get(Calendar.DAY_OF_WEEK);</code></pre>

    <p>On remarque que Calendar.YEAR concerne la classe Calendar et non l’objet date. On peut modifier la date prise en compte dans l’objet date de la façon suivante :</p>
    <pre><code class="language-javascript">date.set(Calendar.YEAR, annee);
date.set(Calendar.MONTH, mois);
date.set(Calendar.DAY_OF_MONTH, jour);
date.set(Calendar.DAY_OF_WEEK, jourDeLaSemaine);</code></pre>

    <fieldset><legend>ATTENTION</legend><p> Calendar.MONTH va de 0 à 11, et 0 est donc le mois de janvier. Calendar.DAY_OF_WEEK va de 1 à 7, et 1 est donc dimanche.</p></fieldset>

    <p>Toutefois, si on veut afficher correctement la date, on peut utiliser</p>
    <pre><code class="language-javascript">System.out.printf("%04d,%02d,%02d,%02d\n",annee,mois,jour,jourSemaine);</code></pre>

    <p>ou encore formatter de la façon suivante :</p>
    <pre><code class="language-javascript">SimpleDateFormat formattage = new SimpleDateFormat("yyyy-MM-dd-EEEE");
System.out.println(formattage.format(date.getTime()));</code></pre>

    <p><em>Exemple de saisie clavier de date puis affichage de la date saisie :</em></p>

    <pre><code class="language-javascript">Scanner saisie = new Scanner(System.in);
System.out.println("entrez année");
int annee = saisie.nextInt();
System.out.println("entrez mois");
int mois = saisie.nextInt();
System.out.println("entrez jour");
int jour = saisie.nextInt();

GregorianCalendar date = new GregorianCalendar(annee,mois,jour);
date.set(Calendar.MONTH, mois-1);
SimpleDateFormat formattage = new SimpleDateFormat("yyyy-MM-dd-EEEE");
System.out.println(formattage.format(date.getTime()));</code></pre>

    </div>



    <!------------- LES LISTES ET DICTIONNAIRES ----------------------------->

    <h3>Les listes et dictionnaires<button type="submit" onclick="affichageConditionnel(this,'listesdictionnaires_cache');"> + </button></h3>

    <div id="listesdictionnaires_cache" style="display:none;">

        <pre><code class="language-javascript">import java.util.*;</code></pre>

    <p>Les collections (ensemble, liste, dictionnaires) sont des conteneurs dynamiques pouvant accepter des objets de types différents et dont la taille varie.</p>

    <p>les ensembles contiennent des éléments non indexés et sans relation d'ordre. On ne peut donc pas y accéder en faisant référence à un String ou un index. Toutefois, on peut parcourir tout l'ensemble et vérifier si un terme appartient à cet ensemble. On les utilise essentiellement pour afficher les éléments d'un dictionnaire après avoir créé un ensemble de clés.</p>

    <p>Les listes contiennent des index auxquels sont associés une valeur unique. Elles s'apparentent à des tableaux sauf que leur taille peut varier et qu'elles peuvent contenir des éléments de types différents.</p>

    <p>Les dictionnaire contiennent des clés auxquelles sont associées une valeur unique.</p>

    <h4>Les listes</h4>

    <table>
        <tr><th>Objectif</th><th>Code</th></tr>
        <tr><td>définir une liste</td><td><pre>ArrayList maListe = new ArrayList();</pre></td></tr>
        <tr><td>définir une liste à partir d'un tableau</td><td><pre>String[] tableau = new String("toto", "tata");
ArraList maListe = new ArrayList(Arrays.asList(tableau));</pre></td></tr>
        <tr><td>définir une liste composée d'un seul type d'élément</td><td><pre>ArrayList&ltString&gt maListe = new ArrayList&ltString&gt();</pre></td></tr>
        <tr><td>ajouter l'élément <em>bonjour</em></td><td><pre>maListe.add("bonjour")</pre></td></tr>
        <tr><td>ajouter l'élément <em>bonjour</em> à l'emplacement d'indice 4</td><td><pre>maListe.add(4, "bonjour")</pre></td></tr>
        <tr><td>remplace l'élément d'indice 4 par <em>bonjour</em></td><td><pre>maListe.set(4, "bonjour")</pre></td></tr>
        <tr><td>renvoyer l'élément d'indice 4</td><td><pre>maListe.get(4)</pre></td></tr>
        <tr><td>renvoyer la taille de maListe</td><td><pre>maListe.size()</pre></td></tr>
        <tr><td>renvoyer l'indice de l'élément <em>bonjour</em></td><td><pre>maListe.indexOf("bonjour")</pre></td></tr>
        <tr><td>supprimer l'élément d'indice 4</td><td><pre>maListe.remove(4)</pre></td></tr>
        <tr><td>comparer l'élément d'indice 4 à celui d'indice 5</td><td><pre>maListe.get(4).equals(maListe.get(5)</pre></td></tr>
        <tr><td>tester si l'élément <em>bonjour</em> appartient à maListe</td><td><pre>maListe.contains("bonjour)</pre></td></tr>
        <tr><td>vider maListe</td><td><pre>maListe.clear()</pre></td></tr>
        <tr><td>copier par valeurs de maListe</td><td><pre>ArrayList listeCopie = (ArrayList) maListe.clone();</pre></td></tr>
    </table>

    <p>ArrayList ne fonctionne qu’avec des types objets pour produire des objets. Ainsi on ne peut pas avoir de liste avec des éléments de type int. Pour pallier ce problème, Java a prévu de faire correspondre à chaque type primitif un objet équivalent. Ainsi au type primitif int correspond l’objet Integer, au type primitif double correspond le type complexe Double. L'autoboxing permet de passer d'un type primitif à son objet correspondant de façon automatisée. En revanche, il convient de déclarer les listes avec les types objet et non les types primitifs. On écrira ainsi :</p>
        <pre><code class="language-javascript">ArrayList&ltInteger&gt maListe = new ArrayList&ltInteger&gt();</code></pre>

    <p>Attention, la comparaison de 2 éléments ne se fait pas avec l'opérateur == car on compare des objets et non des types primitifs.</p>
    <p>Pour afficher une liste :</p>

        <pre><code class="language-javascript">Iterator iterateur = maListe.iterator();
while(iterateur.hasNext()) {
    System.out.print(iterateur.next()+"\t");
}</code></pre>

        <pre><code class="language-javascript">for(int i=0; i&ltmaListe.size();i++) {
    System.out.print(maListe.get(i)+"\t");
}</code></pre>

    <h4>Les dictionnaires</h4>

        <table>
            <tr><th>Objectif</th><th>Code</th></tr>
            <tr><td>définir un dictionnaire</td><td><pre>HashMap dico = new HashMap();</pre></td></tr>
            <tr><td>définir une liste composée d'un type d'élément spécifique</td><td><pre>HashMap&ltString, String&gt dico = new HashMap&ltString, String&gt();</pre></td></tr>
            <tr><td>ajouter l'élément <em>lundi, Monday</em></td><td><pre>dico.put("lundi", Monday)</pre></td></tr>
            <tr><td>remplace l'élément de clé <em>lundi</em></td><td><pre>dico.put("lundi", "Montag")</pre></td></tr>
            <tr><td>renvoyer la valeur de l'élément de clé <em>lundi</em></td><td><pre>dico.get("lundi")</pre></td></tr>
            <tr><td>renvoyer la taille de dico</td><td><pre>dico.size()</pre></td></tr>
            <tr><td>supprimer l'élément de clé <em>lundi</em></td><td><pre>dico.remove("lundi")</pre></td></tr>
            <tr><td>vider dico</td><td><pre>dico.clear()</pre></td></tr>
        </table>

        <p>Pour afficher un dictionnaire :</p>

        <pre><code class="language-javascript">HashMap dico = new HashMap();
Set ensemble = dico.keySet();
for(Object clef : ensemble){
    System.out.println(clef+" :"dico.get(clef));
}</code></pre>

        <pre><code class="language-javascript">Iterator iterateur = ensemble.iterator();
while(iterateur.hasNext()) {
Object clef = iterateur.next();
    System.out.println(clef+":"+dico.get(clef));
}</code></pre>

    </div>


    <!-- ===== LA PROGRAMMATION RESEAU =================================== -->

<h3 id="programmationreseau">La programmation réseau<button type="submit" onclick="affichageConditionnel(this,'programmationreseau_cache');"> + </button></h3>

    <div id="programmationreseau_cache" style="display:none;">

<h4>Rappels sur les réseaux</h4>

<p>La communication réseau est initialement définie par le modèle OSI en 7 couches. Toutefois, la plupart des logiciels reposent sur le modèle TCP/IP en 4 couches : réseau, Internet, transport, application. C'est dans cette dernière couche du modèle TCP/IP que se positionne Java.</p>
<p>Notons que par défaut les principaux protocoles de transfert utilisent les ports suivants :</p>
<ul>
    <li>http : port 80</li>
    <li>ftp : port 20 ou 21</li>
    <li>smtp : port 25</li>
</ul>

<h4>La classe InetAddress</h4>

<p>Pour manipuler des adresses IP, on utilise la classe InetAddress. Par exemple pour obtenir l'adresse IP d'un site connu par son nom de domaine :</p>
<pre><code class="language-javascript">import java.net.*;

try{
    InetAddress adresse = InetAddress.getByName("meteocentrale.ch");
}catch (UnknownHostException e) {
    e.printStackTrace();
}</code></pre>

<p>A noter que dans le cas de l'adresse locale, on peut définir indifféremment :</p>

    <pre><code class="language-javascript">import java.net.*;

try{
    InetAddress adresse = InetAddress.getByName("localhost"); // ou
    InetAddress adresse = InetAddress.getLocalHost();
}catch (UnknownHostException e) {
    e.printStackTrace();
}</code></pre>

    <p>Les méthodes associées à la classe InetAddress nécessitent également la gestion de UnknownHostException :</p>
<table>
    <tr><th>Objectif</th><th>Code</th></tr>
    <tr><td>nom de l'hôte (client)</td><td><pre>adresse.getHostName()</pre></td></tr>
    <tr><td>adresse IP</td><td><pre>adresse.getHostAddress()</pre></td></tr>
    <tr><td>teste si l'adresse est de type boucle locale</td><td><pre>adresse.isLoopbackAddress()</pre></td></tr>
</table>

    <p>Certains sites Internet peuvent avoir plusieurs adresses IP :</p>
<pre><code class="language-javascript">import java.net.*;

try{
    InetAddress[] adresses = InetAddress.getAllByName("amazon.fr");
    System.out.println("Toutes les adresses IP : ");
    for(InetAddress valeur : adresses)
        System.out.println(" - " + valeur.getHostAddress());
}catch(UnknownHostException e) {
        e.printStackTrace();
}</code></pre>

<h4>La classe URL</h4>

<p>On peut également utiliser la classe URL pour récupérer les données d'un site Internet :</p>
<pre><code class="language-javascript">import java.io.*;
import java.net.*;

try {
    URL url = new URL("http://www.meteofrance.fr");
}catch(MalformedURLException e) {
    e.printStackTrace();
}</code></pre>

    <p>Les méthodes associées à la classe URL nécessitent également la gestion de MalformedURLException.</p>

<table>
    <tr><th>Objectif</th><th>Code</th></tr>
    <tr><td>nom du site</td><td>url.getAuthority()</td></tr>
    <tr><td>port par défaut</td><td>url.getDefaultPort()</td></tr>
    <tr><td>nom de l'hébergeur</td><td>url.getHost()</td></tr>
    <tr><td>numéro de port spécifié</td><td>url.getPort()</td></tr>
    <tr><td>protocole</td><td>url.getProtocol()</td></tr>
</table>

<p>Lorsque url.getPort() renvoie -1, cela signifie que le port n'a pas été spécifié dans l'URL.</p>

<p>Pour vérifier qu'une saisie utilisateur correspond à une url, on peut par exemple utiliser la condition :</p>
<pre>if(host.matches("[a-zA-Z\\.]+"))</pre>

    </div>



<!-- ===== PROGRAMMATION CLIENT SERVEUR =================================== -->

<h3 id="programmationclientserveur">Programmation client-serveur<button type="submit" onclick="affichageConditionnel(this,'programmationclientserveur_cache');"> + </button></h3>

    <div id="programmationclientserveur_cache" style="display:none;">

        <div class="pcle"><strong>API Application Programming Interface</strong> : ensemble normalisé de classes, de méthodes qui sert de façade par laquelle un logiciel offre des services à d'autres logiciels. C'est la partie du programme qu'on expose au monde extérieur pour manipuler celui-ci. Ces services sont offerts à travers une bibliothèque ou un service Web. L'API est au développeur ce que l'User Interface est à l'utilisateur.</div>

    <p>Les sockets sont des API permettant de gérer les communications entre programmes. La communication de plusieurs machines sur un réseau nécessite donc la connaissance d'adresses, de ports, de protocoles et l'utilisation de sockets. Les sockets permettent de se connecter à une machine distante, de recevoir et envoyer des données, de fermer une connexion établie, d'attendre une connexion de l'extérieur, d'écouter les communications entrantes. Une même socket sert aussi bien à envoyer qu'à recevoir des communications. Notons également que le protocole TCP/IP s'appuie sur les sockets.</p>

    <p>Une socket est identifiée de manière unique par l'adresse IP de la machine suivie du numéro de port utilisé, ce dernier étant compris entre 1024 et 65536.</p>

    <p>Java fait la différence entre deux types de sockets : côté client et côté serveur.</p>

    <p>Une socket côté client permet de se connecter à une machine distante afin de communiquer avec elle. L'utilisation de socket côté client se déroule ainsi :</p>
    <ul>
        <li>demande de connexion avec le serveur</li>
        <li>ouverture de la communication avec le serveur</li>
        <li>envoi des messages</li>
        <li>fermeture de la connexion</li>
    </ul>

    <p>Un serveur utilise une socket spécifique pour recevoir des demandes de connexion, puis crée une socket de communication pour échanger avec le client. L'utilisation de socket côté serveur se déroule ainsi :</p>
    <ul>
        <li>attente de demande de connexion venant d'un client</li>
        <li>ouverture de la communication avec le client</li>
        <li>traitement des messages</li>
        <li>fermeture de la connexion</li>
    </ul>

    <p>Les sockets travaillent en full-duplex, i.e. le client et le serveur peuvent envoyer et recevoir des signaux simultanément. Il n'y a donc aucune attente.</p>

    <h4>Les différents modes de connexion</h4>

    <p><em>Le mode connecté</em></p>
    <p>En mode connecté, deux sockets établissent une communication durable qui permet d'éviter de transmettre l'identité de la socket destinatrice à chaque envoi. Dans ce cas, un des programmes prend le rôle du serveur et l'autre le rôle du client. Le serveur est donc vu comme un programme rendant des services aux clients.</p>
    <fieldset><legend>IMPORTANT</legend><p>La socket côté serveur doit être lancée avant la socket côté client.</p></fieldset>

    <p>La création d'une socket côté serveur utilise la classe ServerSocket. Le serveur attend ensuite les demandes de connexion en utilisant la fonction bloquante accept() i.e. qu'elle ne libère pas le programme tant qu'elle n'a pas reçu de demande de connexion.</p>

    <p>La création d'une socket côté client utilise la classe Socket.</p>

    <p>Les méthodes de la classe Socket permettant d'obtenir des informations sur la connexion et nécessitent également la gestion de IOException :</p>

    <table>
        <tr><th>Instruction</th><th>Résultat</th></tr>
        <tr><td><pre>socket_client.getInetAddress()</pre></td><td>fournit l'adresse IP distante</td></tr>
        <tr><td><pre>socket_client.getLocalAddress()</pre></td><td>fournit l'adresse IP locale</td></tr>
        <tr><td><pre>socket_client.getPort()</pre></td><td>fournit le nmr de port distant</td></tr>
        <tr><td><pre>socket_client.getLocalPort()</pre></td><td>fournit le nmr de port local</td></tr>
    </table>

    <p>La machine virtuelle Java ferme les sockets non utilisés à la fin de l'exécution du programme. Toutefois, le nombre de sockets ouvertes par un programme est limité, ce qui conduit à des erreurs quand cette limite est atteinte. La méthode close() permet de fermer la connexion.</p>

    <p><em>Le mode non connecté</em></p>
    <p>En mode non connecté, le destinataire de la socket est précisé à chaque envoi. La communication utilise dans ce cas la classe DatagramSocket.</p>

    <fieldset><legend>IMPORTANT</legend><p>En mode non connecté, le programme récepteur doit être lancé en premier.</p></fieldset>

    <h4>Transmission d'une chaîne de caractères en mode connecté :</h4>

    <p><em>Côté serveur : </em></p>

<pre><code class="language-javascript">import java.io.*;
import java.net.*;

public class ServerTCP {

    public static void main(String[] args) {
        try {
            // creation socket serveur communication sur le port 5555
            ServerSocket srv = new ServerSocket(5555);

            // attente demande de connexion venant du client puis creation socket connexion
            Socket conn = srv.accept();

            // communication entrante en provenance du client
            DataInputStream entrant = new DataInputStream(conn.getInputStream());
            System.out.println("Message reçu : " + entrant.readUTF());

            // communication sortante vers le client
            DataOutputStream sortant = new DataOutputStream(conn.getOutputStream());
            sortant.writeUTF("Voici votre information");

            // fermeture connexion
            entrant.close();
            sortant.close();
            conn.close();
            srv.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

    <p><em>Côté client :</em></p>

<pre><code class="language-javascript">import java.io.*;
import java.net.*;

public class ClientTCP {

    public static void main(String[] args) {
        try {
            // creation socket client communication sur le port 5555 en local
            Socket clt = new Socket("localhost", 5555);

            // communication sortante vers le serveur
            DataOutputStream sortant = new DataOutputStream(clt.getOutputStream());
            sortant.writeUTF("Je cherche une information");

            // communication entrante en provenance du serveur
            DataInputStream entrant = new DataInputStream(clt.getInputStream());
            System.out.println("Message reçu : "+ entrant.readUTF());

            // fermeture connexion
            sortant.close();
            entrant.close();
            clt.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

    <p>Les méthodes writeUTF() et readUTF() détectent automatiquement la taille des String dans un flux. Il n'est donc pas nécessaire de la transmettre avec le message. La quantité d'information transmise est donnée par message.length() si on note message la variable représentant le message reçu.</p>

    <p>Il est également possible d'utiliser les instructions write(Byte[] b) et read(Byte[] b) au lieu de writeUTF() et readUTF(). Dans ce cas, l'expéditeur doit envoyer la taille du String en premier pour informer le récepteur de la quantité de données à allouer en mémoire. Il faut créer un buffer pour accueillir le message reçu. Les String sont convertis en Bytes par la méthode .getBytes() avant d'être envoyés, et à la réception l'instruction entrant.read(buffer) ne renvoie pas le message mais la quantité d'information reçue. Il faut alors créer un new String(buffer) pour renvoyer l'information reçue. </p>

    <h4>Transmission d'un entier en mode connecté :</h4>
    <p><em>Côté serveur : </em></p>

<pre><code class="language-javascript">import java.io.*;
import java.net.*;

public class ServerTCP {

    public static void main(String[] args) {
        try {
            ServerSocket srv = new ServerSocket(5555);

            Socket conn = srv.accept();

            DataInputStream entrant = new DataInputStream(conn.getInputStream());
            int message= entrant.readInt();
            System.out.println("Message received: " + message);

            entrant.close();
            conn.close();
            srv.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

    <p><em>Côté client :</em></p>

<pre><code class="language-javascript">import java.io.*;
import java.net.*;

public class ClientTCP {

    public static void main(String[] args) {
        try {
            Socket sock = new Socket("localhost", 5555);

            DataOutputStream sortant = new DataOutputStream(sock.getOutputStream());
            sortant.writeInt(1420);

            sortant.close();
            sock.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

    <h4>Transmission d'un message sous forme d'objet en mode connecté :</h4>

    <p><em>Côté serveur :</em></p>

    <pre><code class="language-javascript">import java.io.*;
import java.net.*;

public class ServerTCP {

    public static void main(String[] args) {

        try {
            // creation socket serveur communication sur le port 5555
            ServerSocket srv = new ServerSocket(5555);

            // attention demande connexion puis creationsocket serveur connexion
            Socket conn = srv.accept();

            // communication entrante, les data sont placees dans un objet
            // transforme en Message, puis en String pour affichage
            DataInputStream dataEntrant = new DataInputStream(conn.getInputStream());
            ObjectInputStream objetEntrant = new ObjectInputStream(dataEntrant);
            Message msg = (Message)objetEntrant.readObject();
            System.out.println("Message reçu : " + msg.toString());

            // fermeture de connexion
            objetEntrant.close();
            dataEntrant.close();
            conn.close();
            srv.close();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) { // doit apparaitre
            e.printStackTrace();
        }
    }
}</code></pre>

    <p><em>Côté client :</em></p>

    <pre><code class="language-javascript">import java.io.*;
import java.net.*;
import java.util.*;

public class ClientTCP {

    public static void main(String[] args) {
        Message msg = new Message("steph",new Date(), "hello world");

        try {
            // creation socket client en local sur le port 5555
            Socket clt = new Socket("localhost", 5555);

            // communication sortante, les data sont placees dans un objet transmis sous forme de Message
            DataOutputStream dataSortant = new DataOutputStream(clt.getOutputStream());
            ObjectOutputStream  objetSortant = new ObjectOutputStream(dataSortant);
            objetSortant.writeObject(msg);

            // fermeture de connexion
            objetSortant.close();
            dataSortant.close();
            clt.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

    <p><em>et la classe Message utilisée :</em></p>

    <pre><code class="language-javascript">import java.io.*;
import java.util.*;

public class Message implements Serializable{
    // un objet de type Message doit etre serialisable pour pouvoir etre transmis
    String name;
    Date date;
    String msg;

    public Message(String name, GregorianCalendar date, String msg){
        this.name = name;
        this.date = date;
        this.msg = msg;
    }

    @Override
    public String toString(){
        return "msg=[ " + name + " , " + date.getTime()+" , "+msg +" ]";
    }
}</code></pre>

    <p><em>Serveur délivrant un service (fournir la date) à tous les clients qui se connectent :</em></p>

    <p><em>Côté serveur :</em></p>

<pre><code class="language-javascript">import java.io.*;
import java.net.*;
import java.util.*;

public class ServerTCP {

    public static void main(String[] args) {
        try {
            ServerSocket srv = new ServerSocket(5555);

            while (true) {
                Socket conn = srv.accept();

                DataOutputStream sortant = new DataOutputStream(conn.getOutputStream());
                sortant.writeUTF("Server Date: " + (new Date()).toString());

                sortant.close();
                conn.close();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

    <p><em>Côté client :</em></p>

<pre><code class="language-javascript">import java.io.*;
import java.net.*;

public class ClientTCP {

    public static void main(String[] args) {
        try {
            Socket clt = new Socket("localhost", 5555);

            DataInputStream entrant = new DataInputStream(clt.getInputStream());
            System.out.println(entrant.readUTF());

            entrant.close();
            clt.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

    <h4>Transmission d'une chaîne de caractères en mode non connecté :</h4>
    <p><em>Côté récepteur :</em></p>

<pre><code class="language-javascript">import java.io.*;
import java.net.*;

public class RecepteurUDP {

    public static void main(String[] args) {
        // creation d'un buffer pour contenir le message a recevoir
        byte[] buffer = new byte[256];

        try {
            // creation de la socket de reception
            DatagramSocket rcp = new DatagramSocket(5555);

            // creation et reception du paquet
            DatagramPacket packet = new DatagramPacket(buffer, buffer.length);
            rcp.receive(packet);
            System.out.println("Message recu =  " + new String(buffer));

            // fermeture de connexion
            rcp.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

    <p><em>Côté émetteur :</em></p>
    <pre><code class="language-javascript">import java.io.*;
import java.net.*;

public class EmetteurUDP {

    public static void main(String[] args) {
        String message = "rendez-vous à 13h.";

        try {
            // creation de la socket emettrice
            DatagramSocket emt = new DatagramSocket();

            // recuperation de l'adresse IP
            InetAddress adresseIP = InetAddress.getByName("localhost");

            // creation du packet et envoi du message
            DatagramPacket packet = new DatagramPacket(message.getBytes(), message.getBytes().length, adresseIP, 5555);
            emt.send(packet);

            // fermeture connexion
            emt.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

    <h4>Transmission d'un entier en mode non connecté :</h4>
    <p><em>Côté récepteur : </em></p>

<pre><code class="language-javascript">import java.io.*;
import java.net.*;
import java.nio.*;

public class RecepteurUDP {

    public static void main(String[] args) {
        byte[] buffer = new byte[256];
        try {
            DatagramSocket rcp = new DatagramSocket(5555);

            DatagramPacket packet = new DatagramPacket(buffer, buffer.length);
            rcp.receive(packet);

            // conversion du message reçu en byte[] vers un entier
            int entier = ByteBuffer.wrap(buffer).getInt();
            System.out.println("Message recu :  " + entier);

            // fermeture de connexion
            rcp.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

    <p><em>Côté émetteur : </em></p>

<pre><code class="language-javascript">import java.io.*;
import java.net.*;
import java.nio.*;

public class EmetteurUDP {

    public static void main(String[] args) {
        // transformation de l'entier en byte[]
        ByteBuffer tabByte = ByteBuffer.allocate(4);
        byte[] buffer =  tabByte.putInt(1402).array();

        try {
            DatagramSocket emt = new DatagramSocket();

            InetAddress adresseIP = InetAddress.getByName("localhost");

            DatagramPacket packet = new DatagramPacket(buffer, buffer.length, adresseIP, 5555);
            emt.send(packet);

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

    <h4>Tester les ports disponibles du client</h4>

    <p>Pour tester les 1024 premiers ports du client à l'aide de cette classe :</p>
    <pre><code class="language-javascript">for(int i = 1; i <= 1024; i++){
    try {
        Socket soc = new Socket("127.0.0.1", i);
        System.out.println("ports autorisés sur la machine : " + i);
    } catch (UnknownHostException e) {
        e.printStackTrace();
    }catch (IOException e) {
        System.out.println("ioexception");
        // le port n'est pas ouvert ou n'est pas autorisé
    }
}</code></pre>

<p>Pour spécifier sur quel port du client le serveur devra répondre :</p>
    <pre><code class="language-javascript">try {
    //Nous spécifions que la réponse devra se faire par ce chemin
    InetAddress lo = InetAddress.getByName("188.165.53.185");

    //Le fait de mettre 0 dans le numéro de port de réponse
    //informe que n'importe quel numéro est accepté
    Socket soc = new Socket("www.adret-attitude.ch", 80, lo, 0);
}catch (UnknownHostException e) {
    e.printStackTrace();
} catch (Exception e) {
    e.printStackTrace();
}</code></pre>

    <h4>Communiquer avec un serveur</h4>

    <p>On utilise l'objet HttpURLConnection.</p>
    <p>Les flux BufferedInputStrean et BufferedOutputStrean permettent de gagner en performance plutôt que de travailler directement avec les sockets.</p>

    </div>



    <!-- ===== LES PROXYS ======================================= -->

    <h3 id="proxys">Les proxys<button type="submit" onclick="affichageConditionnel(this,'proxys_cache');"> + </button></h3>

    <div id="proxys_cache" style="display:none;">

    <p>Un proxy constitue une autre façon de se connecter à un serveur. Le proxy est un intermédiaire faisant le lien entre le client et le serveur.</p>
<pre><code class="language-javascript">import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.Proxy;
import java.net.Socket;
import java.net.SocketAddress;

//On crée une adresse correspondant à notre proxy
SocketAddress proxyAddress = new InetSocketAddress("10.10.10.10", 8080);

//On instancie la classe Proxy avec le type souhaité
Proxy proxy = new Proxy(Proxy.Type.SOCKS, proxyAddress);

//On crée notre socket utilisant le proxy
Socket s = new Socket(proxy);

//On crée l'adresse que l'on souhaite atteindre via le proxy
SocketAddress remote = new InetSocketAddress("www.adret-attitude.ch", 80);
try {
    //On connecte le tout !
    s.connect(remote);
} catch (IOException e) {
    e.printStackTrace();
}</code></pre>

    <p></p>

    <table>
        <tr><th>Objectif</th><th>Code</th></tr>
        <tr><td>port côté serveur</td><td>s.getPort()</td></tr>
        <tr><td>port côté client</td><td>s.getLocalPort()</td></tr>
        <tr><td>nom hôte distant</td><td>s.getInetAddress().getHostName()</td></tr>
        <tr><td>adresse hôte distant</td><td>s.getInetAddress().getHostAddress()</td></tr>
        <tr><td>adresse socket hôte distant</td><td>s.getRemoteSocketAddress()</td></tr>
    </table>

    <pre><code class="language-javascript">try {
    Socket s = new Socket("www.adret-attitude.ch", 80);
    System.out.println("Port de communication côté serveur : " + s.getPort());
    System.out.println("Port de communication côté client : " + s.getLocalPort());
    System.out.println("Nom de l'hôte distant : " + s.getInetAddress().getHostName());
    System.out.println("Adresse de l'hôte distant : " + s.getInetAddress().getHostAddress());
    System.out.println("Adresse socket de l'hôte distant : " + s.getRemoteSocketAddress());
} catch (UnknownHostException e) {
        e.printStackTrace();
} catch (IOException e) {
        e.printStackTrace();
}</code></pre>

    </div>



    <!-- Le RMI ------------------------------>

    <h3 id="mecanismermi">Le mécanisme RMI<button type="submit" onclick="affichageConditionnel(this,'mecanismermi_cache');"> + </button></h3>

    <div id="mecanismermi_cache" style="display:none;">

    <p>Le RMI permet d'appeler du code à distance, en créant un objet distant sur une machine serveur qui est rendu accessible aux autres machines. Il faut définir :</p>
        <ul>
            <li>l'interface de l'objet distant</li>
            <li>l'implémentation</li>
            <li>l'application serveur</li>
            <li>l'application client</li>
        </ul>

    <p>Le client peut récupérer une représentation locale de l'objet distant appelée talon ou <em>stub</em>, qui utilise une représentation distante appelée <em>skeleton</em>. Le client utilise alors ce talon comme si l'objet distant était local. Ainsi, le <em>stub</em> sert de lien côté client avec l'interface alors que le <em>skeleton</em> sert de lien côté serveur avec l'interface. Le registry qui définit les liens entre <em>stub</em> et <em>skeleton</em> est créé en ligne de commande par l'instruction rmiregistry.</p>
    <p>Cette technique offre pour avantages de mettre à jour le client de manière transparente et de masquer l'exécution distante du code tout en travaillant comme si l'exécution était locale.</p>

    <img src="skeleton.png" width="300" height="250">

    <p>L'interface est l'entité partagée par le client et le serveur, donc présente des deux côtés.</p>

    <pre><code class="language-javascript">import java.rmi.*;

public interface Hello extends Remote {
    public void sayHello(String nom) throws RemoteException;
}</code></pre>

    <h4>Côté serveur</h4>

    <p>L'implémentation de l'interface se fait côté serveur et ne doit pas être présente côté client sous peine de perdre l'utilité de RMI.  et l'implémentation côté serveur hérite de l'interface.</p>

    <pre><code class="language-javascript">import java.rmi.server.*;
import java.rmi.*;

public class HelloImpl extends UnicastRemoteObject implements Hello {
    public HelloImpl() throws RemoteException {
        super();
    }
    public void sayHello(String nom) throws RemoteException {
        System.out.println("Hello "+nom");
    }
}</code></pre>

    <p>Dans la classe principale côté serveur, il faut instancier l'implémentation, puis le <em>skeleton</em> est défini pour transmettre les appels à l'objet distant.</p>

    <pre><code class="language-javascript">import java.rmi.*;
import java.net.*;

class HelloServer {
    public static void main(String[] args) {
        try {
            HelloImpl obj = new HelloImpl();
            Naming.rebind("Hello", obj);
        } catch (RemoteException e) {
            e.printStackTrace();
        } catch (MalformedURLException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

    <h4>Côté client</h4>
    Le <em>stub</em> implémente l'interface de l'objet distant pour le client
    <p>L'appel côté client d'une méthode d'un objet distant consiste à obtenir une référence sur l'objet distant puis à appeler la méthode à partir de cette référence.</p>
    <pre><code class="language-javascript">import java.rmi.*;
import java.net.*;

class HelloClient {
    public static void main(String[] args) {
        try {
            // arg[0] represente l'url qui sera le 1er argument entre en ligne de commande
            // lors de l'exécution java HelloClient localhost:5555
            Hello obj = (Hello) Naming.lookup("//"+args[0]+"/Hello");
            obj.sayHello("Mike");
        } catch (RemoteException e) {
            e.printStackTrace();
        } catch (NotBoundException e) {
            e.printStackTrace();
        } catch (MalformedURLException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

    <fieldset><legend>ATTENTION</legend>L'appel à distance d'une méthode n'est pas équivalent à l'appel local de cette méthode. Dans le cas d'un appel distant, les paramètres, les valeurs de retour et les exceptions sont transmis par copie et doivent donc être sérialisables. Or les types primitifs et les objets distants le sont par défaut. En revanche, les types créés ne sont pas sérialisables mais peuvent le devenir si les classes correspondantes implémentent l'interface java.io.Serializable.</fieldset>

    <p>Notons que l'application cliente devra également gérer la synchronisation des appels à distance à l'aide de threads pour éviter le blocage du système.</p>

<p><em>Exemple d'une boite de messagerie :</em> le client peut déposer un message après s'être inscrit et consulter son message.</p>
<p><em>L'interface :</em></p>

<pre><code class="language-javascript">import java.rmi.*;

public interface Boite extends Remote{
    public int inscrire() throws RemoteException;
    public void envoieMessage(int nclient, Message mess) throws RemoteException;
    public Message getMessage(int nclient) throws RemoteException;
}</code></pre>

    <p><em>Côté serveur :</em></p>

    <p>La classe Message :</p>
<pre><code class="language-javascript">import java.util.*;
import java.io.*;

public class Message implements Serializable{
    public String nom;
    public String message;
    public GregorianCalendar date;

    public Message(String nom, GregorianCalendar date, String message) {
        this.nom = nom;
        this.date = date;
        this.message = message;
    }

    @Override
    public String toString(){
        return "Le "+date.getTime()+" "+nom+" a écrit : "+message;
    }
}</code></pre>

    <p>l'implémentation :</p>
<pre><code class="language-javascript">import java.rmi.*;
import java.rmi.server.*;
import java.util.*;

public class BoiteMessageImpl extends UnicastRemoteObject implements Boite{
    public static int nmrClient;
    public Vector vectMess;

    public BoiteMessageImpl() throws RemoteException{
        super();
        nmrClient = 0;
        vectMess = new Vector(10);
    }

    public int inscrire() throws RemoteException{
        return nmrClient++;
    }

    public void envoieMessage(int nclient, Message mess) throws RemoteException{
        vectMess.add(nclient, mess);
    }

    public Message getMessage(int nclient) throws RemoteException {
        return (Message)vectMess.get(nclient);
    }
}</code></pre>

    <p>et la classe principale :</p>
<pre><code class="language-javascript">import java.rmi.*;
import java.net.*;

public class BoiteServer {
    public static void main(String[] args){
        try{
            BoiteMessageImpl obj = new BoiteMessageImpl();
            Naming.rebind("Boite", obj);
        }catch(RemoteException e){
            e.printStackTrace();
        }catch(MalformedURLException e){
            e.printStackTrace();
        }
    }
}</code></pre>

    <p><em>Côté client :</em></p>

    <p>La classe principale :</p>
<pre><code class="language-javascript">import java.rmi.*;
import java.net.*;
import java.util.*;

public class BoiteClient {
    public static void main(String[] args){
        try{
            Boite boiteMess = (Boite)Naming.lookup("//"+args[0]+"/Boite");
            int nclient = boiteMess.inscrire();
            Message m = new Message("Mike", new GregorianCalendar(), "hello world");
            boiteMess.envoieMessage(nbclient, m);
            System.out.println("Dernier message : "+boiteMess.getMessage(nclient).toString());
        }catch(RemoteException e){
            e.printStackTrace();
        }catch(NotBoundException e){
            e.printStackTrace();
        }catch(MalformedURLException e){
            e.printStackTrace();
        }
    }
}</code></pre>

    </div>



    <!-- JMS --------------------------------------->

    <h3 id="jms">Le mécanisme JMS<button type="submit" onclick="affichageConditionnel(this,'jms_cache');"> + </button></h3>

    <div id="jms_cache" style="display:none;">

    <div class="pcle">message : ensemble de données groupées pour être envoyées et reçues en même temps.</br>
        <em>serveur d'application :</em> infrastructure offrant un contexte d'exécution pour des composants applicatifs.</div>

    <p>JMS Java Message Service est une interface de programmation API spécialisée dans la création, l'envoi et la lecture de messages. JMS s'apparente donc à un service de messagerie permettant d'envoyer des messages d'une application à une autre sur un poste distant. Les particularités de JMS sont les suivantes :</p>
        <ul>
            <li>asynchrone, un message arrivera au client sans qu'il n'ait fait de requête</li>
            <li>fiable, il s'assure que le message soit délivré</li>
        </ul>

    <p>La particularité de la communication par message vient du fait que les messages sont envoyés sur un objet intermédiaire MOM Message Oriented Middleware, et le consumer doit venir les chercher. Des bus gèrent les transports de messages vers les objets intermédiaires. Ce mode de communication indirect permet de mettre en place des services avancés :</p>
    <ul>
        <li>transaction : envoi et réception groupés</li>
        <li>persistance : retransmission des messages en cas de panne</li>
        <li>multicast : communication de groupe</li>
        <li>log : trace des échanges</li>
        <li>gestion des droits d'accès</li>
    </ul>

    <p>JMS repose sur deux modes de communication principaux : la communication point-à-point et la communication événementielle. Chacun de ces modes de communication utilise des objets intermédiaires par lesquels transitent les messages et accessibles via un objet JMSConnectionFactory. De ce fait, il est inutile d'établir une connexion entre un émetteur et un récepteur.</p>

    <p>Dans la communication point-à-point, l'objet intermédiaire est une file d'attente (queue). Plusieurs senders peuvent envoyer sur la même file d'attente mais un seul receiver peut voir le message. On parle de communication N à 1. La communication est asynchrone et mémorisée.</p>

    <p>Dans la communication événementielle, l'objet intermédiaire est un sujet (topic). Les publishers envoient leurs messages sur un topic. Les subscribers s'inscrivent au topic pour recevoir les messages publiés sur ce topic. Plusieurs publishers peuvent envoyer des messages sur le même topic et plusieurs subscribers peuvent consulter les messages du topic.</p>

    <p>JMS contient les classes suivantes :</p>
    <ul>
        <li>le fournisseur est l'objet intermédiaire qui jour le rôle de plateforme de messagerie</li>
        <li>le publisher/sender créé des messages</li>
        <li>le subscriber/receiver lit les messages</li>
        <li>le message contient des informations communiquées entre clients</li>
        <li>les objets administrés sont configurés par un administrateur</li>
    </ul>
    <p>Il existe différents types de fournisseurs, comme par exemple ActiveMQ de Apache. Les objets administrés ne sont pas traités dans ce résumé. Nous allons donc présenter les classes Publisher/Sender, Subscriber/Receiver et Message.</p>

    <h4>Construction d'un service de messagerie Topic avec JMS 1.1</h4>

    <p><em>Côté Publisher :</em></p>

<pre><code class="language-javascript">import java.util.*;
import javax.naming.*;
import javax.jms.*;

public class Publisher {

    public static void main(String[] args) {
		try {
			// initialisation, le detail des proprietes se trouve dans jndi.properties
	    	Properties props = new Properties();
	    	InitialContext ctx = new InitialContext();

	    	// connexion au provider et à l'objet intermediaire
	    	ConnectionFactory factory = (ConnectionFactory) ctx.lookup("Fournisseur");

	    	// creation et acces au topic
	    	Topic topic = (Topic) ctx.lookup("MyTopic");

		    // connexion de l'utilisateur au bus
	    	Connection conn = factory.createConnection();

	    	// creation de session
	    	Session sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);

		    // creation d'un objet emetteur
	   		MessageProducer producer = sess.createProducer(topic);
	    	// topicPublisher.setDeliveryMode(DeliveryMode.NON_PERSISTENT);

			// publication d'un message "hello world"
	    	TextMessage message = sess.createTextMessage();
	    	message.setText("hello world");
	    	producer.send(message);

	    	// fermeture de connexion
	    	conn.close();
		} catch (Exception e) {
	    	e.printStackTrace();
		}
    }
}</code></pre>

    <p><em>Côté Subscriber :</em></p>

<pre><code class="language-javascript">import javax.naming.*;
import javax.jms.*;

public class Subscriber {

    public static void main(String[] args) {
		try {
	    	// initialisation
	    	InitialContext ctx = new InitialContext();

		    // connexion au provider et à l'objet intermediaire
	    	ConnectionFactory factory = (ConnectionFactory) ctx.lookup("ConnectionFactory");

			// creation et acces au topic
			Topic topic = (Topic) ctx.lookup("MyTopic");

	    	// connexion de l'utilisateur au bus
	    	Connection conn = factory.createConnection();

		    // creation de session
	    	Session sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);

	    	// creation d'un objet destinataire
	    	MessageConsumer consumer = sess.createConsumer(topic);

		    // lecture d'un message, receive est une fonction bloquante
		    conn.start();
	    	TextMessage message = (TextMessage) consumer.receive();
	    	System.out.println("message lu : " + message.getText());

		    // fermeture connexion
		    conn.close();
		} catch( Exception e ) {
	    	e.printStackTrace();
		}
    }
}</code></pre>

    <h4>Construction d'un service de messagerie Queue avec JMS 1.1</h4>

<p><em>Côté Sender</em></p>

    <pre><code class="language-javascript">import javax.naming.*;
import javax.jms.*;

public class Sender {

    public static void main(String[] args) {
		try {
			// initialisation
	    	InitialContext ctx = new InitialContext();

			// connexion au provider et à l'objet intermediaire
	    	ConnectionFactory factory = (ConnectionFactory) ctx.lookup("Fournisseur");

			// creation et acces a la file d'attente
			Queue queue = (Queue) ctx.lookup("MyQueue");

			// connexion de l'utilisateur au bus
	    	Connection conn = factory.createConnection();

			// creation de session
	    	Session sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);

			// creation d'un objet emetteur
	    	MessageProducer producer = sess.createProducer(queue);
	    	producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);

			// envoi d'un message "hello world"
	    	TextMessage message = sess.createTextMessage("hello world");
	   		producer.send(message);

		    // fermeture connexion
	   		conn.close();
		} catch( Exception e ) {
	    	e.printStackTrace();
		}
    }
}</code></pre>

    <p><em>Côté Receiver :</em></p>

    <pre><code class="language-javascript">import javax.naming.*;
import javax.jms.*;

public class Receiver {

    public static void main(String[] args) {
		try {
	    	// initialisation
	    	InitialContext ctx = new InitialContext();

	    	// connexion au provider et a l'objet intermediaire
	    	ConnectionFactory factory = (ConnectionFactory) ctx.lookup("Fournisseur");

			// creation et acces a la file d'attente
			Queue queue = (Queue) ctx.lookup("MyQueue");

	    	// connexion de l'utilisateur au bus
	    	Connection conn = factory.createConnection();

	    	// creation de session
	    	Session sess = connect.createSession(false, Session.AUTO_ACKNOWLEDGE);

	    	// creation d'un objet destinataire
	    	MessageConsumer consumer = sess.createConsumer(queue);

	    	// lecture d'un message, receive est une fonction bloquante
	    	conn.start();
	    	TextMessage message = (TextMessage) consumer.receive();
		    System.out.println("message reçu: " + message.getText());

	    	// fermeture connexion
	    	conn.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
    }
}</code></pre>

    <h4>Echange de mails avec JMS 1.1</h4>

    <p><em>Côté Sender</em></p>

    <pre><code class="language-javascript">import javax.naming.*;
import javax.jms.*;
import java.util.*;

public class Sender {

	public static void main(String[] args) {
		try {
	    	// initialisation
	    	InitialContext ctx = new InitialContext();

	    	// connexion au fournisseur et a l'objet intermediaire
	    	QueueConnectionFactory factory = (QueueConnectionFactory) ctx.lookup("fournisseur");

			// creation et acces a la file d'attente
			Queue queue = (Queue) ctx.lookup("MyQueue");

	    	// connexion de l'utilisateur au bus
	    	QueueConnection conn = factory.createQueueConnection();

	    	// creation de session
	    	QueueSession sess = conn.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);

	    	// creation d'un objet emetteur
	    	QueueSender producer = sess.createSender(queue);
	    	producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);

	    	// envoi d'un mail
	    	GregorianCalendar date = new GregorianCalendar(2016,11,24);
	    	Letter letter = new Letter("moi", date, "Hello");
	    	ObjectMessage message = sess.createObjectMessage(letter);
	    	conn.start();
	    	producer.send(message);

	    	// attente que le destinataire reçoive le message
	    	Thread.sleep( 5000 );

	    	// creation d'un objet destinataire
	    	QueueReceiver consumer = queueSession.createReceiver(queue);

	    	// reception d'un message reponse
	    	TextMessage reponse = (TextMessage) consumer.receive();
	    	System.out.println("received: " + reponse.getText());

	    	// fermeture connexion
	    	conn.close();
		} catch ( Exception e ) {
	    	e.printStackTrace();
		}
    }
}</code></pre>

    <p><em>Côté Receiver</em></p>

    <pre><code class="language-javascript">import javax.naming.*;
import javax.jms.*;
import java.util.*;

public class TP12Receiver {

    public static void main(String[] args) {
		try {
	    	// initialisation
	    	InitialContext ctx = new InitialContext();

	    	// connexion au fournisseur et a l'objet intermediaire
	    	QueueConnectionFactory factory = (QueueConnectionFactory) ctx.lookup("Fournisseur");

			// creation et acces a la file d'attente
			Queue queue = (Queue) ctx.lookup("MyQueue");

	    	// connexion de l'utilisateur au bus
	    	QueueConnection conn = factory.createQueueConnection();

	    	// creation de session
	    	QueueSession sess = conn.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);

	    	// creation d'un objet destinataire
	    	QueueReceiver consumer = sess.createReceiver(queue);

	    	// lecture d'un mail
	    	conn.start();
	    	ObjectMessage message = (ObjectMessage) consumer.receive();
	    	Letter letter = (Letter) message.getObject();
	    	System.out.print("mail reçu : "+ letter.toString());

	    	// creation d'un objet emetteur
	    	QueueSender producer = sess.createSender(queue);
	    	producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);

	    	// envoi d'un message reponse
	    	TextMessage reponse = sess.createTextMessage("Merci");
	    	producer.send(reponse);

	    	// fermeture connexion
	    	conn.close();
		} catch (Exception e) {
	    	e.printStackTrace();
		}
    }
}</code></pre>

    <p><em>et la classe Letter :</em></p>

    <pre><code class="language-javascript">import java.util.*;
import java.io.*;

public class Letter implements Serializable {
    String emetteur;
    GregorianCalendar date;
    String texte;

    public Letter(String emetteur, GregorianCalendar date, String texte) {
	    this.emetteur = emetteur;
	    this.date = date;
	    this.texte = texte;
    }

    @Override
    public String toString() {
        System.out.println("message de : " + emet + ", émis le : " + date.getTime() + ", contenu : " + text );
    }
}</code></pre>

    </div>



    <!-- Les services Web -------------------------------------------------->

    <h3 id="servicesweb">Les services Web<button type="submit" onclick="affichageConditionnel(this,'servicesweb_cache');"> + </button></h3>

    <div id="servicesweb_cache" style="display:none;">

    <div class="pcle"><strong>sérialisation</strong> : codage d'une information sous fome de suite de données atomiques.</br>
    <strong>parser un fichier</strong> : analyser un fichier afin d'en retirer les informations utiles.</br>
        <strong>serveur d'applications</strong> : logiciel d'infrastructure offrant un contexte d'exécution pour des applications Web et non pas de simples procédures ou scripts.</br>
        <strong>verbe HTTP</strong> : méthodes HTTP GET, POST, PUT, DELETE, ...</br>
    <strong>POJO Plain Old Java Object </strong> : objet Java lié à aucune restriction autre que celles forcées par la spécification du langage Java. Ainsi un POJO n'étend pas de classe pré-définie, n'implémente pas d'interface et ne contient pas d'annotation pré-spécifiée @...</div>

    <p>Les services Web sont un ensemble de technologies permettant l'invocation de méthodes distantes. La communication et l'échange de données sont basés sur les standards Web HTTP et XML. SOAP et REST sont 2 solutions permettant à un client d'accéder aux services Web.</p>

    <p>Les principaux avantages des services Web sont les suivants :</p>
    <ul>
        <li>portabilité entre différents langages, différents systèmes d'exploitation</li>
        <li>utilisation de standards et protocoles ouverts</li>
        <li>utilisation des formats XNL dans les échanges de données</li>
        <li>flexibilité, extensibilité</li>
    </ul>

    <h4>SOAP Simple Object Access Protocol (depracated)</h4>

    <p>SOAP est un protocole de RPC Remote Procedure Call orienté objet et basé sur l'échange de données structurées en XML. SOAP permet l'appel de méthodes distantes dans un environnement distribué.</p>
    <p>Un message SOAP est un document XML composé d'une <em>envelope</em> avec un <em>header</em> et le <em>body</em>, corps du message. Dans le cas de l'envoi d'une image, on peut utiliser un message SOAP avec attachement en utilisant un message MIME Multimedia Internet Mail Extension.</p>

    <p>L'architecture des services SOAP se base sur les protocoles suivants :</p>
    <ul>
        <li>un protocole de transfert HTTP ou SMTP, les données échangées sont représentées en XML</li>
        <li>un protocole de description des services et méthodes WSDL</li>
        <li>un protocole de localisation des services UDDI</li>
    </ul>

    <p>WSDL Web Service Description Langage donne la description au format XML des services Web en précisant les méthodes pouvant être invoquées. Le client a besoin de cette description détaillée des services Web avant de pouvoir les utiliser.</p>

    <p>UDDI Universal Description Discovery and Integration est un annuaire des services publiés par les providers. Une entrée du répertoire UDDI est constituée d'un fichier XML.</p>

    <p><em>Exemple de requête SOAP :</em></p>

    <pre><code class="language-javascript">HTTP/1.1 200 OK
Content-Type: text/xml; charset=utf-8
Content-Length: length

&lt?xml version="1.0" encoding="utf-8"?&gt
&ltsoap:Envelope xmlns:soap="http://www.w3.org/2001/soap/envelope"&gt
&ltsoap:Body&gt
    &ltm:GetPrice xmlns:m="http://www.w3schools.com/prices"&gt
        &ltm:Item&gtApples&lt/m:Item&gt
    &lt/m:GetPrice&gt
&lt/soap:Body&gt
&lt/soap:Envelope&gt</code></pre>

    <p><em>Réponse SOAP :</em></p>

    <pre><code class="language-javascript">HTTP/1.1 200 OK
Content-Type: text/xml; charset=utf-8
Content-Length: length

&lt?xml version="1.0" encoding="utf-8"?&gt
&ltsoap:Envelope xmlns:soap="http://www.w3.org/2001/soap/envelope"&gt
&ltsoap:Body&gt
    &ltm:GetPriceResponse xmlns:m="http://www.w3schools.com/prices"&gt
        &ltm:Price&gt2.59&lt/m:Price&gt
    &lt/m:GetPriceResponse&gt
&lt/soap:Body&gt
&lt/soap:Envelope&gt</code></pre>

    <h4>Développement d'un service Web SOAP avec JAX-WS</h4>

    <p>JAX-WS est intégré dans Java pour développer des services Web.</p>
    <p>Le développement d'un service Web SOAP avec JAX-WS se fait en plusieurs étapes :</p>
    <ul>
        <li>créer une interface publique</li>
        <li>implémenter l'interface</li>
        <li>publier et déployer l'application localement</li>
    </ul>

    <pre><code class="language-javascript">// interface publique
import javax.jws.*;
import javax.jws.soap.*;

@WebService
@SOAPBinding(style = Style.RCP)
public interface HelloWorld {
    String getHelloWorldAsString(String nom);
}</code></pre>

    <pre><code class="language-javascript">// implémentation de l'interface
import javax.jws.*;

@WebService(endpointInterface = "ws.HelloWorld")
public class HelloWorldImpl implements HelloWorld {

    @Overrride
    public String getHelloWorldAsString(String nom) {
        return "Hello World JAX-WS "+nom;
    }
}</code></pre>

<pre><code class="language-javascript">// publication de l'application et déploiement
import javax.xml.ws.*;

public class HelleWorldPublisher {
    public static void main(String[] args) {
        Endpoint.publish("http://localhost:9999/ws/hello", new HelloWorldIml());
    }
}</code></pre>

    <h4>REST Representational State Transfer</h4>

    <p>Le service Web de type REST est plus souple que le type SOAP qui est maintenant désué. REST est une API dans lequel on ne trouve pas de contrat comme pour RMI ou SOAP.</p>
    <p>REST se base sur le protocole HTTP pour transférer les ressources qui sont identifiées par des URI Uniform Resource Identifier.</p>

    <p>Les URI regroupent 2 sous-types d'identificateurs, les URN Uniform Resource Name et les URL Uniform Resource Locator. Les URL comprennent les chemins d'accès aux ressources accessibles. Par exemple http://domaine/chemin et mailto: adresseMail@gmail.com sont des URL. Les URN permettent de définir une identification unique et persistance pour une ressource. Par exemple l'adresse MAC d'une ordinateur, la référence ISBN:0-233-988897-2 d'un livre sont des URN.</p>

    <p>Les principales caractéristiques des services REST sont les suivantes :</p>
    <ul>
        <li>identification des ressources via des URI</li>
        <li>manipulation des ressources avec uniquement 4 opérations CRUD : Create avec la méthode POST, Retrieve avec la méthode GET, Update avec la méthode PUT et Delete avec la méthode DELETE</li>
        <li>les ressources sont séparées de leur représentation HTML, XML, PDF, JPEG, JSON</li>
    </ul>

    <p>Plusieurs frameworks aident au développement des Web services REST en prenant en charge l'analyse et le traitement des requêtes côté serveur et des réponses côté client, comme par exemple Spring. L'interface Java pour implémenter des services Web REST s'appelle JAX-RS, basée sur des POJO (Plain Old Java Object)</p>

    <p>Les services Web REST sont généralement déployés dans les serveurs d'application comme Tomcat et JBoss.</p>

    <p>Les requêtes du protocole HTTP sont composées d'une ligne de commande, d'une entête et d'un corps de message. Le format de stockage des données est pincipalement JSON JavaScript Object Notation, contrairement à SOAP qui utilisait XML.</p>

    <p><em>Exemple de format JSON :</em></p>

<pre><code class="language-javascript">{
    'prenom': 'Stephane',
    'nom': 'Dupret',
    'age': 35,
    'adresse': {
        'rue': '12 bd de la libération',
        'ville': 'Marseille',
        'codePostal': '13013'
    },
    'numerosTph': [
        {
        'type': 'domicile',
        'nmr': '01234567889'
        },
        {
        'type': 'bureau',
        'nmr': '0198765432'
        }
    ]
}</code></pre>

    <p><pre>Exemple d'utilisation de JSON avec le package Gson</pre></p>

    <pre><code class="language-javascript">import com.google.gson.Gson
Gson gson = new Gson();
MyInData mid = new MyInData(45, 0.1, "hello");
String toJsonString = gson.toJson(mid);

MyInData fromJsonString = gson.froJson(jsonString, MyInData.class);</code></pre>

<p><em>Exemple de service REST :</em></p>

    <pre><code class="language-javascript">@Path('helloworld')
public class HelloWorldResource {
    public static final String MESSAGE ='hello world';

    @GET
    @Produces('text/plain')
    public String getHello() {
        return MESSAGE;
    }
}</code></pre>

    <p>L'annotation @Path permet d'indiquer que l'objet doit être exposé comme un service répondant à des requêtes REST.</p>

    <p><em>Les principaux codes statut de réponse : </em></p>
        <ul>
            <li>200 OK : tout s'est bien passé</li>
            <li>201 Created : la création de la ressource s'est bien passée</li>
            <li>204 No content : tout s'est bien passé mais le contenu de la ressource n'est pas renvoyé en réponse</li>
            <li>304 Not modified : le contenu n'a pas été modifié</li>
            <li>400 Bad request : la demande n'a pas pu être traitée correctement</li>
            <li>401 Unauthorized : l'authentification a échoué</li>
            <li>404 Not found : la ressource n'existe pas</li>
            <li>405 Method not allowed : la méthode HTTP utilisée n'est pas traitable par l'API</li>
            <li>406 Not acceptable : l'API n'est pas capable de fournir le format demandé</li>
            <li>500 Server error : le serveur a rencontré un problème</li>
        </ul>
    </div>

</section>

<footer>
    Stephane Robin
</footer>

</body>
</html>
